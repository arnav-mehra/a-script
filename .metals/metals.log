2024.01.09 01:21:20 INFO  Started: Metals version 1.2.0 in folders 'C:\Users\Arnav\Documents\GitHub\apl\apl' for client Visual Studio Code 1.85.1.
2024.01.09 01:21:24 WARN  Build server is not auto-connectable.
2024.01.09 01:21:24 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:21:24 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
2024.01.09 01:21:27 INFO  no build target found for C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.01.09 01:21:28 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\index.scala
Jan 09, 2024 1:21:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10
2024.01.09 01:21:30 INFO  time: code lens generation in 1.75s
2024.01.09 01:21:30 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 01:21:30 INFO  time: code lens generation in 6.07s
2024.01.09 01:21:30 INFO  time: code lens generation in 1.97s
2024.01.09 01:24:16 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
2024.01.09 01:24:16 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:24:25 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\index.scala
2024.01.09 01:24:25 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:27:12 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 01:27:12 INFO  skipping build import with status 'Dismissed'
Jan 09, 2024 1:28:27 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 244
2024.01.09 01:29:29 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 01:29:29 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:31:07 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 01:31:07 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:31:16 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 01:31:16 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:31:57 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 01:31:57 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:39:04 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 01:39:04 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:39:13 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 01:39:13 INFO  skipping build import with status 'Dismissed'
Jan 09, 2024 1:51:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1628
2024.01.09 01:51:19 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 01:51:19 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:54:48 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 01:54:48 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:55:55 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 01:55:55 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:56:17 WARN  Could not find semantic tokens for: file:///C:/Users/Arnav/Documents/GitHub/apl/apl/index.scala
2024.01.09 01:56:18 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\index.scala
2024.01.09 01:56:18 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:56:18 WARN  Could not find semantic tokens for: file:///C:/Users/Arnav/Documents/GitHub/apl/apl/index.scala
2024.01.09 01:56:35 WARN  Using indexes to guess the definition of Data
2024.01.09 01:56:43 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
2024.01.09 01:56:43 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:56:49 WARN  Using indexes to guess the definition of Data
2024.01.09 01:56:57 WARN  Using indexes to guess the definition of Data
2024.01.09 01:56:57 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
2024.01.09 01:56:57 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:56:57 WARN  Using indexes to guess the definition of Data
2024.01.09 01:57:22 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
2024.01.09 01:57:22 INFO  skipping build import with status 'Dismissed'
Jan 09, 2024 1:58:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2267
2024.01.09 01:58:19 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
Jan 09, 2024 1:58:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2299
2024.01.09 01:58:19 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:58:38 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
2024.01.09 01:58:38 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:59:03 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
2024.01.09 01:59:03 INFO  skipping build import with status 'Dismissed'
2024.01.09 01:59:30 WARN  Using indexes to guess the definition of Data
Exception in thread "pool-3-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.01.09 01:59:52 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
2024.01.09 01:59:52 INFO  skipping build import with status 'Dismissed'
2024.01.09 02:00:10 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
2024.01.09 02:00:10 INFO  skipping build import with status 'Dismissed'
2024.01.09 02:00:16 WARN  Using indexes to guess the definition of Data
2024.01.09 02:00:16 WARN  Using indexes to guess the definition of Data
2024.01.09 09:45:15 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 09:45:15 INFO  skipping build import with status 'Dismissed'
2024.01.09 09:49:20 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 09:49:20 INFO  skipping build import with status 'Dismissed'
2024.01.09 09:49:56 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 09:49:56 INFO  skipping build import with status 'Dismissed'
Jan 09, 2024 9:50:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3072
2024.01.09 09:50:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1+1/lib/src.zip!/java.base/java/lang/Number.java

Uri: jar:file:///C:/Program Files/Java/jdk-17.0.8.1+1/lib/src.zip!/java.base/java/lang/Number.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Jan 09, 2024 9:50:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17.0.8.1%2B1/lib/src.zip%21/java.base/java/lang/Number.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\n/**\n * The abstract class {@code Number} is the superclass of platform\n * classes representing numeric values that are convertible to the\n * primitive types {@code byte}, {@code double}, {@code float}, {@code\n * int}, {@code long}, and {@code short}.\n *\n * The specific semantics of the conversion from the numeric value of\n * a particular {@code Number} implementation to a given primitive\n * type is defined by the {@code Number} implementation in question.\n *\n * For platform classes, the conversion is often analogous to a\n * narrowing primitive conversion or a widening primitive conversion\n * as defined in \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e\n * for converting between primitive types.  Therefore, conversions may\n * lose information about the overall magnitude of a numeric value, may\n * lose precision, and may even return a result of a different sign\n * than the input.\n *\n * See the documentation of a given {@code Number} implementation for\n * conversion details.\n *\n * @author      Lee Boynton\n * @author      Arthur van Hoff\n * @jls 5.1.2 Widening Primitive Conversion\n * @jls 5.1.3 Narrowing Primitive Conversion\n * @since   1.0\n */\npublic abstract class Number implements java.io.Serializable {\n    /**\n     * Constructor for subclasses to call.\n     */\n    public Number() {super();}\n\n    /**\n     * Returns the value of the specified number as an {@code int}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code int}.\n     */\n    public abstract int intValue();\n\n    /**\n     * Returns the value of the specified number as a {@code long}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code long}.\n     */\n    public abstract long longValue();\n\n    /**\n     * Returns the value of the specified number as a {@code float}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code float}.\n     */\n    public abstract float floatValue();\n\n    /**\n     * Returns the value of the specified number as a {@code double}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code double}.\n     */\n    public abstract double doubleValue();\n\n    /**\n     * Returns the value of the specified number as a {@code byte}.\n     *\n     * @implSpec\n     * The default implementation returns the result of {@link #intValue} cast\n     * to a {@code byte}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code byte}.\n     * @since   1.1\n     */\n    public byte byteValue() {\n        return (byte)intValue();\n    }\n\n    /**\n     * Returns the value of the specified number as a {@code short}.\n     *\n     * @implSpec\n     * The default implementation returns the result of {@link #intValue} cast\n     * to a {@code short}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code short}.\n     * @since   1.1\n     */\n    public short shortValue() {\n        return (short)intValue();\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -8742448824652078965L;\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Number.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Number.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Jan 09, 2024 9:50:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17.0.8.1%2B1/lib/src.zip%21/java.base/java/lang/Number.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Number.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Number.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.01.09 09:50:31 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1+1/lib/src.zip!/java.base/java/lang/Number.java

Uri: jar:file:///C:/Program Files/Java/jdk-17.0.8.1+1/lib/src.zip!/java.base/java/lang/Number.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Jan 09, 2024 9:50:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17.0.8.1%2B1/lib/src.zip%21/java.base/java/lang/Number.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\n/**\n * The abstract class {@code Number} is the superclass of platform\n * classes representing numeric values that are convertible to the\n * primitive types {@code byte}, {@code double}, {@code float}, {@code\n * int}, {@code long}, and {@code short}.\n *\n * The specific semantics of the conversion from the numeric value of\n * a particular {@code Number} implementation to a given primitive\n * type is defined by the {@code Number} implementation in question.\n *\n * For platform classes, the conversion is often analogous to a\n * narrowing primitive conversion or a widening primitive conversion\n * as defined in \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e\n * for converting between primitive types.  Therefore, conversions may\n * lose information about the overall magnitude of a numeric value, may\n * lose precision, and may even return a result of a different sign\n * than the input.\n *\n * See the documentation of a given {@code Number} implementation for\n * conversion details.\n *\n * @author      Lee Boynton\n * @author      Arthur van Hoff\n * @jls 5.1.2 Widening Primitive Conversion\n * @jls 5.1.3 Narrowing Primitive Conversion\n * @since   1.0\n */\npublic abstract class Number implements java.io.Serializable {\n    /**\n     * Constructor for subclasses to call.\n     */\n    public Number() {super();}\n\n    /**\n     * Returns the value of the specified number as an {@code int}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code int}.\n     */\n    public abstract int intValue();\n\n    /**\n     * Returns the value of the specified number as a {@code long}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code long}.\n     */\n    public abstract long longValue();\n\n    /**\n     * Returns the value of the specified number as a {@code float}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code float}.\n     */\n    public abstract float floatValue();\n\n    /**\n     * Returns the value of the specified number as a {@code double}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code double}.\n     */\n    public abstract double doubleValue();\n\n    /**\n     * Returns the value of the specified number as a {@code byte}.\n     *\n     * @implSpec\n     * The default implementation returns the result of {@link #intValue} cast\n     * to a {@code byte}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code byte}.\n     * @since   1.1\n     */\n    public byte byteValue() {\n        return (byte)intValue();\n    }\n\n    /**\n     * Returns the value of the specified number as a {@code short}.\n     *\n     * @implSpec\n     * The default implementation returns the result of {@link #intValue} cast\n     * to a {@code short}.\n     *\n     * @return  the numeric value represented by this object after conversion\n     *          to type {@code short}.\n     * @since   1.1\n     */\n    public short shortValue() {\n        return (short)intValue();\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -8742448824652078965L;\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Number.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Number.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Jan 09, 2024 9:50:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17.0.8.1%2B1/lib/src.zip%21/java.base/java/lang/Number.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Number.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Number.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.01.09 09:50:33 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 09:50:33 INFO  skipping build import with status 'Dismissed'
2024.01.09 09:52:37 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1+1/lib/src.zip!/java.base/java/lang/Double.java

Uri: jar:file:///C:/Program Files/Java/jdk-17.0.8.1+1/lib/src.zip!/java.base/java/lang/Double.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Jan 09, 2024 9:52:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17.0.8.1%2B1/lib/src.zip%21/java.base/java/lang/Double.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Optional;\n\nimport jdk.internal.math.FloatingDecimal;\nimport jdk.internal.math.DoubleConsts;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\n/**\n * The {@code Double} class wraps a value of the primitive type\n * {@code double} in an object. An object of type\n * {@code Double} contains a single field whose type is\n * {@code double}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting a\n * {@code double} to a {@code String} and a\n * {@code String} to a {@code double}, as well as other\n * constants and methods useful when dealing with a\n * {@code double}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003ch2\u003e\u003ca id\u003dequivalenceRelation\u003eFloating-point Equality, Equivalence,\n * and Comparison\u003c/a\u003e\u003c/h2\u003e\n *\n * IEEE 754 floating-point values include finite nonzero values,\n * signed zeros ({@code +0.0} and {@code -0.0}), signed infinities\n * {@linkplain Double#POSITIVE_INFINITY positive infinity} and\n * {@linkplain Double#NEGATIVE_INFINITY negative infinity}), and\n * {@linkplain Double#NaN NaN} (not-a-number).\n *\n * \u003cp\u003eAn \u003cem\u003eequivalence relation\u003c/em\u003e on a set of values is a boolean\n * relation on pairs of values that is reflexive, symmetric, and\n * transitive. For more discussion of equivalence relations and object\n * equality, see the {@link Object#equals Object.equals}\n * specification. An equivalence relation partitions the values it\n * operates over into sets called \u003ci\u003eequivalence classes\u003c/i\u003e.  All the\n * members of the equivalence class are equal to each other under the\n * relation. An equivalence class may contain only a single member. At\n * least for some purposes, all the members of an equivalence class\n * are substitutable for each other.  In particular, in a numeric\n * expression equivalent values can be \u003cem\u003esubstituted\u003c/em\u003e for one\n * another without changing the result of the expression, meaning\n * changing the equivalence class of the result of the expression.\n *\n * \u003cp\u003eNotably, the built-in {@code \u003d\u003d} operation on floating-point\n * values is \u003cem\u003enot\u003c/em\u003e an equivalence relation. Despite not\n * defining an equivalence relation, the semantics of the IEEE 754\n * {@code \u003d\u003d} operator were deliberately designed to meet other needs\n * of numerical computation. There are two exceptions where the\n * properties of an equivalence relation are not satisfied by {@code\n * \u003d\u003d} on floating-point values:\n *\n * \u003cul\u003e\n *\n * \u003cli\u003eIf {@code v1} and {@code v2} are both NaN, then {@code v1\n * \u003d\u003d v2} has the value {@code false}. Therefore, for two NaN\n * arguments the \u003cem\u003ereflexive\u003c/em\u003e property of an equivalence\n * relation is \u003cem\u003enot\u003c/em\u003e satisfied by the {@code \u003d\u003d} operator.\n *\n * \u003cli\u003eIf {@code v1} represents {@code +0.0} while {@code v2}\n * represents {@code -0.0}, or vice versa, then {@code v1 \u003d\u003d v2} has\n * the value {@code true} even though {@code +0.0} and {@code -0.0}\n * are distinguishable under various floating-point operations. For\n * example, {@code 1.0/+0.0} evaluates to positive infinity while\n * {@code 1.0/-0.0} evaluates to \u003cem\u003enegative\u003c/em\u003e infinity and\n * positive infinity and negative infinity are neither equal to each\n * other nor equivalent to each other. Thus, while a signed zero input\n * most commonly determines the sign of a zero result, because of\n * dividing by zero, {@code +0.0} and {@code -0.0} may not be\n * substituted for each other in general. The sign of a zero input\n * also has a non-substitutable effect on the result of some math\n * library methods.\n *\n * \u003c/ul\u003e\n *\n * \u003cp\u003eFor ordered comparisons using the built-in comparison operators\n * ({@code \u003c}, {@code \u003c\u003d}, etc.), NaN values have another anomalous\n * situation: a NaN is neither less than, nor greater than, nor equal\n * to any value, including itself. This means the \u003ci\u003etrichotomy of\n * comparison\u003c/i\u003e does \u003cem\u003enot\u003c/em\u003e hold.\n *\n * \u003cp\u003eTo provide the appropriate semantics for {@code equals} and\n * {@code compareTo} methods, those methods cannot simply be wrappers\n * around {@code \u003d\u003d} or ordered comparison operations. Instead, {@link\n * Double#equals equals} defines NaN arguments to be equal to each\n * other and defines {@code +0.0} to \u003cem\u003enot\u003c/em\u003e be equal to {@code\n * -0.0}, restoring reflexivity. For comparisons, {@link\n * Double#compareTo compareTo} defines a total order where {@code\n * -0.0} is less than {@code +0.0} and where a NaN is equal to itself\n * and considered greater than positive infinity.\n *\n * \u003cp\u003eThe operational semantics of {@code equals} and {@code\n * compareTo} are expressed in terms of {@linkplain #doubleToLongBits\n * bit-wise converting} the floating-point values to integral values.\n *\n * \u003cp\u003eThe \u003cem\u003enatural ordering\u003c/em\u003e implemented by {@link #compareTo\n * compareTo} is {@linkplain Comparable consistent with equals}. That\n * is, two objects are reported as equal by {@code equals} if and only\n * if {@code compareTo} on those objects returns zero.\n *\n * \u003cp\u003eThe adjusted behaviors defined for {@code equals} and {@code\n * compareTo} allow instances of wrapper classes to work properly with\n * conventional data structures. For example, defining NaN\n * values to be {@code equals} to one another allows NaN to be used as\n * an element of a {@link java.util.HashSet HashSet} or as the key of\n * a {@link java.util.HashMap HashMap}. Similarly, defining {@code\n * compareTo} as a total ordering, including {@code +0.0}, {@code\n * -0.0}, and NaN, allows instances of wrapper classes to be used as\n * elements of a {@link java.util.SortedSet SortedSet} or as keys of a\n * {@link java.util.SortedMap SortedMap}.\n *\n * @jls 4.2.3 Floating-Point Types, Formats, and Values\n * @jls 4.2.4. Floating-Point Operations\n * @jls 15.21.1 Numerical Equality Operators \u003d\u003d and !\u003d\n * @jls 15.20.1 Numerical Comparison Operators {@code \u003c}, {@code \u003c\u003d}, {@code \u003e}, and {@code \u003e\u003d}\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Double extends Number\n        implements Comparable\u003cDouble\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the positive infinity of type\n     * {@code double}. It is equal to the value returned by\n     * {@code Double.longBitsToDouble(0x7ff0000000000000L)}.\n     */\n    public static final double POSITIVE_INFINITY \u003d 1.0 / 0.0;\n\n    /**\n     * A constant holding the negative infinity of type\n     * {@code double}. It is equal to the value returned by\n     * {@code Double.longBitsToDouble(0xfff0000000000000L)}.\n     */\n    public static final double NEGATIVE_INFINITY \u003d -1.0 / 0.0;\n\n    /**\n     * A constant holding a Not-a-Number (NaN) value of type\n     * {@code double}. It is equivalent to the value returned by\n     * {@code Double.longBitsToDouble(0x7ff8000000000000L)}.\n     */\n    public static final double NaN \u003d 0.0d / 0.0;\n\n    /**\n     * A constant holding the largest positive finite value of type\n     * {@code double},\n     * (2-2\u003csup\u003e-52\u003c/sup\u003e)\u0026middot;2\u003csup\u003e1023\u003c/sup\u003e.  It is equal to\n     * the hexadecimal floating-point literal\n     * {@code 0x1.fffffffffffffP+1023} and also equal to\n     * {@code Double.longBitsToDouble(0x7fefffffffffffffL)}.\n     */\n    public static final double MAX_VALUE \u003d 0x1.fffffffffffffP+1023; // 1.7976931348623157e+308\n\n    /**\n     * A constant holding the smallest positive normal value of type\n     * {@code double}, 2\u003csup\u003e-1022\u003c/sup\u003e.  It is equal to the\n     * hexadecimal floating-point literal {@code 0x1.0p-1022} and also\n     * equal to {@code Double.longBitsToDouble(0x0010000000000000L)}.\n     *\n     * @since 1.6\n     */\n    public static final double MIN_NORMAL \u003d 0x1.0p-1022; // 2.2250738585072014E-308\n\n    /**\n     * A constant holding the smallest positive nonzero value of type\n     * {@code double}, 2\u003csup\u003e-1074\u003c/sup\u003e. It is equal to the\n     * hexadecimal floating-point literal\n     * {@code 0x0.0000000000001P-1022} and also equal to\n     * {@code Double.longBitsToDouble(0x1L)}.\n     */\n    public static final double MIN_VALUE \u003d 0x0.0000000000001P-1022; // 4.9e-324\n\n    /**\n     * Maximum exponent a finite {@code double} variable may have.\n     * It is equal to the value returned by\n     * {@code Math.getExponent(Double.MAX_VALUE)}.\n     *\n     * @since 1.6\n     */\n    public static final int MAX_EXPONENT \u003d 1023;\n\n    /**\n     * Minimum exponent a normalized {@code double} variable may\n     * have.  It is equal to the value returned by\n     * {@code Math.getExponent(Double.MIN_NORMAL)}.\n     *\n     * @since 1.6\n     */\n    public static final int MIN_EXPONENT \u003d -1022;\n\n    /**\n     * The number of bits used to represent a {@code double} value.\n     *\n     * @since 1.5\n     */\n    public static final int SIZE \u003d 64;\n\n    /**\n     * The number of bytes used to represent a {@code double} value.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code double}.\n     *\n     * @since 1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cDouble\u003e   TYPE \u003d (Class\u003cDouble\u003e) Class.getPrimitiveClass(\"double\");\n\n    /**\n     * Returns a string representation of the {@code double}\n     * argument. All characters mentioned below are ASCII characters.\n     * \u003cul\u003e\n     * \u003cli\u003eIf the argument is NaN, the result is the string\n     *     \"{@code NaN}\".\n     * \u003cli\u003eOtherwise, the result is a string that represents the sign and\n     * magnitude (absolute value) of the argument. If the sign is negative,\n     * the first character of the result is \u0027{@code -}\u0027\n     * ({@code \u0027\\u005Cu002D\u0027}); if the sign is positive, no sign character\n     * appears in the result. As for the magnitude \u003ci\u003em\u003c/i\u003e:\n     * \u003cul\u003e\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is infinity, it is represented by the characters\n     * {@code \"Infinity\"}; thus, positive infinity produces the result\n     * {@code \"Infinity\"} and negative infinity produces the result\n     * {@code \"-Infinity\"}.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is zero, it is represented by the characters\n     * {@code \"0.0\"}; thus, negative zero produces the result\n     * {@code \"-0.0\"} and positive zero produces the result\n     * {@code \"0.0\"}.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is greater than or equal to 10\u003csup\u003e-3\u003c/sup\u003e but less\n     * than 10\u003csup\u003e7\u003c/sup\u003e, then it is represented as the integer part of\n     * \u003ci\u003em\u003c/i\u003e, in decimal form with no leading zeroes, followed by\n     * \u0027{@code .}\u0027 ({@code \u0027\\u005Cu002E\u0027}), followed by one or\n     * more decimal digits representing the fractional part of \u003ci\u003em\u003c/i\u003e.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is less than 10\u003csup\u003e-3\u003c/sup\u003e or greater than or\n     * equal to 10\u003csup\u003e7\u003c/sup\u003e, then it is represented in so-called\n     * \"computerized scientific notation.\" Let \u003ci\u003en\u003c/i\u003e be the unique\n     * integer such that 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e \u0026le; \u003ci\u003em\u003c/i\u003e {@literal \u003c}\n     * 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e+1\u003c/sup\u003e; then let \u003ci\u003ea\u003c/i\u003e be the\n     * mathematically exact quotient of \u003ci\u003em\u003c/i\u003e and\n     * 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e so that 1 \u0026le; \u003ci\u003ea\u003c/i\u003e {@literal \u003c} 10. The\n     * magnitude is then represented as the integer part of \u003ci\u003ea\u003c/i\u003e,\n     * as a single decimal digit, followed by \u0027{@code .}\u0027\n     * ({@code \u0027\\u005Cu002E\u0027}), followed by decimal digits\n     * representing the fractional part of \u003ci\u003ea\u003c/i\u003e, followed by the\n     * letter \u0027{@code E}\u0027 ({@code \u0027\\u005Cu0045\u0027}), followed\n     * by a representation of \u003ci\u003en\u003c/i\u003e as a decimal integer, as\n     * produced by the method {@link Integer#toString(int)}.\n     * \u003c/ul\u003e\n     * \u003c/ul\u003e\n     * How many digits must be printed for the fractional part of\n     * \u003ci\u003em\u003c/i\u003e or \u003ci\u003ea\u003c/i\u003e? There must be at least one digit to represent\n     * the fractional part, and beyond that as many, but only as many, more\n     * digits as are needed to uniquely distinguish the argument value from\n     * adjacent values of type {@code double}. That is, suppose that\n     * \u003ci\u003ex\u003c/i\u003e is the exact mathematical value represented by the decimal\n     * representation produced by this method for a finite nonzero argument\n     * \u003ci\u003ed\u003c/i\u003e. Then \u003ci\u003ed\u003c/i\u003e must be the {@code double} value nearest\n     * to \u003ci\u003ex\u003c/i\u003e; or if two {@code double} values are equally close\n     * to \u003ci\u003ex\u003c/i\u003e, then \u003ci\u003ed\u003c/i\u003e must be one of them and the least\n     * significant bit of the significand of \u003ci\u003ed\u003c/i\u003e must be {@code 0}.\n     *\n     * \u003cp\u003eTo create localized string representations of a floating-point\n     * value, use subclasses of {@link java.text.NumberFormat}.\n     *\n     * @param   d   the {@code double} to be converted.\n     * @return a string representation of the argument.\n     */\n    public static String toString(double d) {\n        return FloatingDecimal.toJavaFormatString(d);\n    }\n\n    /**\n     * Returns a hexadecimal string representation of the\n     * {@code double} argument. All characters mentioned below\n     * are ASCII characters.\n     *\n     * \u003cul\u003e\n     * \u003cli\u003eIf the argument is NaN, the result is the string\n     *     \"{@code NaN}\".\n     * \u003cli\u003eOtherwise, the result is a string that represents the sign\n     * and magnitude of the argument. If the sign is negative, the\n     * first character of the result is \u0027{@code -}\u0027\n     * ({@code \u0027\\u005Cu002D\u0027}); if the sign is positive, no sign\n     * character appears in the result. As for the magnitude \u003ci\u003em\u003c/i\u003e:\n     *\n     * \u003cul\u003e\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is infinity, it is represented by the string\n     * {@code \"Infinity\"}; thus, positive infinity produces the\n     * result {@code \"Infinity\"} and negative infinity produces\n     * the result {@code \"-Infinity\"}.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is zero, it is represented by the string\n     * {@code \"0x0.0p0\"}; thus, negative zero produces the result\n     * {@code \"-0x0.0p0\"} and positive zero produces the result\n     * {@code \"0x0.0p0\"}.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is a {@code double} value with a\n     * normalized representation, substrings are used to represent the\n     * significand and exponent fields.  The significand is\n     * represented by the characters {@code \"0x1.\"}\n     * followed by a lowercase hexadecimal representation of the rest\n     * of the significand as a fraction.  Trailing zeros in the\n     * hexadecimal representation are removed unless all the digits\n     * are zero, in which case a single zero is used. Next, the\n     * exponent is represented by {@code \"p\"} followed\n     * by a decimal string of the unbiased exponent as if produced by\n     * a call to {@link Integer#toString(int) Integer.toString} on the\n     * exponent value.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is a {@code double} value with a subnormal\n     * representation, the significand is represented by the\n     * characters {@code \"0x0.\"} followed by a\n     * hexadecimal representation of the rest of the significand as a\n     * fraction.  Trailing zeros in the hexadecimal representation are\n     * removed. Next, the exponent is represented by\n     * {@code \"p-1022\"}.  Note that there must be at\n     * least one nonzero digit in a subnormal significand.\n     *\n     * \u003c/ul\u003e\n     *\n     * \u003c/ul\u003e\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption\u003eExamples\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eFloating-point Value\u003c/th\u003e\u003cth scope\u003d\"col\"\u003eHexadecimal String\u003c/th\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody style\u003d\"text-align:right\"\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code 1.0}\u003c/th\u003e \u003ctd\u003e{@code 0x1.0p0}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code -1.0}\u003c/th\u003e        \u003ctd\u003e{@code -0x1.0p0}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code 2.0}\u003c/th\u003e \u003ctd\u003e{@code 0x1.0p1}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code 3.0}\u003c/th\u003e \u003ctd\u003e{@code 0x1.8p1}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code 0.5}\u003c/th\u003e \u003ctd\u003e{@code 0x1.0p-1}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code 0.25}\u003c/th\u003e        \u003ctd\u003e{@code 0x1.0p-2}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code Double.MAX_VALUE}\u003c/th\u003e\n     *     \u003ctd\u003e{@code 0x1.fffffffffffffp1023}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code Minimum Normal Value}\u003c/th\u003e\n     *     \u003ctd\u003e{@code 0x1.0p-1022}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code Maximum Subnormal Value}\u003c/th\u003e\n     *     \u003ctd\u003e{@code 0x0.fffffffffffffp-1022}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code Double.MIN_VALUE}\u003c/th\u003e\n     *     \u003ctd\u003e{@code 0x0.0000000000001p-1022}\u003c/td\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param   d   the {@code double} to be converted.\n     * @return a hex string representation of the argument.\n     * @since 1.5\n     * @author Joseph D. Darcy\n     */\n    public static String toHexString(double d) {\n        /*\n         * Modeled after the \"a\" conversion specifier in C99, section\n         * 7.19.6.1; however, the output of this method is more\n         * tightly specified.\n         */\n        if (!isFinite(d) )\n            // For infinity and NaN, use the decimal output.\n            return Double.toString(d);\n        else {\n            // Initialized to maximum size of output.\n            StringBuilder answer \u003d new StringBuilder(24);\n\n            if (Math.copySign(1.0, d) \u003d\u003d -1.0)    // value is negative,\n                answer.append(\"-\");                  // so append sign info\n\n            answer.append(\"0x\");\n\n            d \u003d Math.abs(d);\n\n            if(d \u003d\u003d 0.0) {\n                answer.append(\"0.0p0\");\n            } else {\n                boolean subnormal \u003d (d \u003c Double.MIN_NORMAL);\n\n                // Isolate significand bits and OR in a high-order bit\n                // so that the string representation has a known\n                // length.\n                long signifBits \u003d (Double.doubleToLongBits(d)\n                                   \u0026 DoubleConsts.SIGNIF_BIT_MASK) |\n                    0x1000000000000000L;\n\n                // Subnormal values have a 0 implicit bit; normal\n                // values have a 1 implicit bit.\n                answer.append(subnormal ? \"0.\" : \"1.\");\n\n                // Isolate the low-order 13 digits of the hex\n                // representation.  If all the digits are zero,\n                // replace with a single 0; otherwise, remove all\n                // trailing zeros.\n                String signif \u003d Long.toHexString(signifBits).substring(3,16);\n                answer.append(signif.equals(\"0000000000000\") ? // 13 zeros\n                              \"0\":\n                              signif.replaceFirst(\"0{1,12}$\", \"\"));\n\n                answer.append(\u0027p\u0027);\n                // If the value is subnormal, use the E_min exponent\n                // value for double; otherwise, extract and report d\u0027s\n                // exponent (the representation of a subnormal uses\n                // E_min -1).\n                answer.append(subnormal ?\n                              Double.MIN_EXPONENT:\n                              Math.getExponent(d));\n            }\n            return answer.toString();\n        }\n    }\n\n    /**\n     * Returns a {@code Double} object holding the\n     * {@code double} value represented by the argument string\n     * {@code s}.\n     *\n     * \u003cp\u003eIf {@code s} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     *\n     * \u003cp\u003eLeading and trailing whitespace characters in {@code s}\n     * are ignored.  Whitespace is removed as if by the {@link\n     * String#trim} method; that is, both ASCII space and control\n     * characters are removed. The rest of {@code s} should\n     * constitute a \u003ci\u003eFloatValue\u003c/i\u003e as described by the lexical\n     * syntax rules:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eFloatValue:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code NaN}\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code Infinity}\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e FloatingPointLiteral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e HexFloatingPointLiteral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSignedInteger\u003c/i\u003e\n     * \u003c/dl\u003e\n     *\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eHexFloatingPointLiteral\u003c/i\u003e:\n     * \u003cdd\u003e \u003ci\u003eHexSignificand BinaryExponent FloatTypeSuffix\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n     * \u003c/dl\u003e\n     *\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eHexSignificand:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e {@code .}\n     * \u003cdd\u003e{@code 0x} \u003ci\u003eHexDigits\u003csub\u003eopt\u003c/sub\u003e\n     *     \u003c/i\u003e{@code .}\u003ci\u003e HexDigits\u003c/i\u003e\n     * \u003cdd\u003e{@code 0X}\u003ci\u003e HexDigits\u003csub\u003eopt\u003c/sub\u003e\n     *     \u003c/i\u003e{@code .} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003c/dl\u003e\n     *\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eBinaryExponent:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eBinaryExponentIndicator SignedInteger\u003c/i\u003e\n     * \u003c/dl\u003e\n     *\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eBinaryExponentIndicator:\u003c/i\u003e\n     * \u003cdd\u003e{@code p}\n     * \u003cdd\u003e{@code P}\n     * \u003c/dl\u003e\n     *\n     * \u003c/blockquote\u003e\n     *\n     * where \u003ci\u003eSign\u003c/i\u003e, \u003ci\u003eFloatingPointLiteral\u003c/i\u003e,\n     * \u003ci\u003eHexNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, \u003ci\u003eSignedInteger\u003c/i\u003e and\n     * \u003ci\u003eFloatTypeSuffix\u003c/i\u003e are as defined in the lexical structure\n     * sections of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     * If {@code s} does not have the form of\n     * a \u003ci\u003eFloatValue\u003c/i\u003e, then a {@code NumberFormatException}\n     * is thrown. Otherwise, {@code s} is regarded as\n     * representing an exact decimal value in the usual\n     * \"computerized scientific notation\" or as an exact\n     * hexadecimal value; this exact numerical value is then\n     * conceptually converted to an \"infinitely precise\"\n     * binary value that is then rounded to type {@code double}\n     * by the usual round-to-nearest rule of IEEE 754 floating-point\n     * arithmetic, which includes preserving the sign of a zero\n     * value.\n     *\n     * Note that the round-to-nearest rule also implies overflow and\n     * underflow behaviour; if the exact value of {@code s} is large\n     * enough in magnitude (greater than or equal to ({@link\n     * #MAX_VALUE} + {@link Math#ulp(double) ulp(MAX_VALUE)}/2),\n     * rounding to {@code double} will result in an infinity and if the\n     * exact value of {@code s} is small enough in magnitude (less\n     * than or equal to {@link #MIN_VALUE}/2), rounding to float will\n     * result in a zero.\n     *\n     * Finally, after rounding a {@code Double} object representing\n     * this {@code double} value is returned.\n     *\n     * \u003cp\u003e To interpret localized string representations of a\n     * floating-point value, use subclasses of {@link\n     * java.text.NumberFormat}.\n     *\n     * \u003cp\u003eNote that trailing format specifiers, specifiers that\n     * determine the type of a floating-point literal\n     * ({@code 1.0f} is a {@code float} value;\n     * {@code 1.0d} is a {@code double} value), do\n     * \u003cem\u003enot\u003c/em\u003e influence the results of this method.  In other\n     * words, the numerical value of the input string is converted\n     * directly to the target floating-point type.  The two-step\n     * sequence of conversions, string to {@code float} followed\n     * by {@code float} to {@code double}, is \u003cem\u003enot\u003c/em\u003e\n     * equivalent to converting a string directly to\n     * {@code double}. For example, the {@code float}\n     * literal {@code 0.1f} is equal to the {@code double}\n     * value {@code 0.10000000149011612}; the {@code float}\n     * literal {@code 0.1f} represents a different numerical\n     * value than the {@code double} literal\n     * {@code 0.1}. (The numerical value 0.1 cannot be exactly\n     * represented in a binary floating-point number.)\n     *\n     * \u003cp\u003eTo avoid calling this method on an invalid string and having\n     * a {@code NumberFormatException} be thrown, the regular\n     * expression below can be used to screen the input string:\n     *\n     * \u003cpre\u003e{@code\n     *  final String Digits     \u003d \"(\\\\p{Digit}+)\";\n     *  final String HexDigits  \u003d \"(\\\\p{XDigit}+)\";\n     *  // an exponent is \u0027e\u0027 or \u0027E\u0027 followed by an optionally\n     *  // signed decimal integer.\n     *  final String Exp        \u003d \"[eE][+-]?\"+Digits;\n     *  final String fpRegex    \u003d\n     *      (\"[\\\\x00-\\\\x20]*\"+  // Optional leading \"whitespace\"\n     *       \"[+-]?(\" + // Optional sign character\n     *       \"NaN|\" +           // \"NaN\" string\n     *       \"Infinity|\" +      // \"Infinity\" string\n     *\n     *       // A decimal floating-point string representing a finite positive\n     *       // number without a leading sign has at most five basic pieces:\n     *       // Digits . Digits ExponentPart FloatTypeSuffix\n     *       //\n     *       // Since this method allows integer-only strings as input\n     *       // in addition to strings of floating-point literals, the\n     *       // two sub-patterns below are simplifications of the grammar\n     *       // productions from section 3.10.2 of\n     *       // The Java Language Specification.\n     *\n     *       // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n     *       \"(((\"+Digits+\"(\\\\.)?(\"+Digits+\"?)(\"+Exp+\")?)|\"+\n     *\n     *       // . Digits ExponentPart_opt FloatTypeSuffix_opt\n     *       \"(\\\\.(\"+Digits+\")(\"+Exp+\")?)|\"+\n     *\n     *       // Hexadecimal strings\n     *       \"((\" +\n     *        // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n     *        \"(0[xX]\" + HexDigits + \"(\\\\.)?)|\" +\n     *\n     *        // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n     *        \"(0[xX]\" + HexDigits + \"?(\\\\.)\" + HexDigits + \")\" +\n     *\n     *        \")[pP][+-]?\" + Digits + \"))\" +\n     *       \"[fFdD]?))\" +\n     *       \"[\\\\x00-\\\\x20]*\");// Optional trailing \"whitespace\"\n     *\n     *  if (Pattern.matches(fpRegex, myString))\n     *      Double.valueOf(myString); // Will not throw NumberFormatException\n     *  else {\n     *      // Perform suitable alternative action\n     *  }\n     * }\u003c/pre\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     a {@code Double} object holding the value\n     *             represented by the {@code String} argument.\n     * @throws     NumberFormatException  if the string does not contain a\n     *             parsable number.\n     */\n    public static Double valueOf(String s) throws NumberFormatException {\n        return new Double(parseDouble(s));\n    }\n\n    /**\n     * Returns a {@code Double} instance representing the specified\n     * {@code double} value.\n     * If a new {@code Double} instance is not required, this method\n     * should generally be used in preference to the constructor\n     * {@link #Double(double)}, as this method is likely to yield\n     * significantly better space and time performance by caching\n     * frequently requested values.\n     *\n     * @param  d a double value.\n     * @return a {@code Double} instance representing {@code d}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Double valueOf(double d) {\n        return new Double(d);\n    }\n\n    /**\n     * Returns a new {@code double} initialized to the value\n     * represented by the specified {@code String}, as performed\n     * by the {@code valueOf} method of class\n     * {@code Double}.\n     *\n     * @param  s   the string to be parsed.\n     * @return the {@code double} value represented by the string\n     *         argument.\n     * @throws NullPointerException  if the string is null\n     * @throws NumberFormatException if the string does not contain\n     *         a parsable {@code double}.\n     * @see    java.lang.Double#valueOf(String)\n     * @since 1.2\n     */\n    public static double parseDouble(String s) throws NumberFormatException {\n        return FloatingDecimal.parseDouble(s);\n    }\n\n    /**\n     * Returns {@code true} if the specified number is a\n     * Not-a-Number (NaN) value, {@code false} otherwise.\n     *\n     * @param   v   the value to be tested.\n     * @return  {@code true} if the value of the argument is NaN;\n     *          {@code false} otherwise.\n     */\n    public static boolean isNaN(double v) {\n        return (v !\u003d v);\n    }\n\n    /**\n     * Returns {@code true} if the specified number is infinitely\n     * large in magnitude, {@code false} otherwise.\n     *\n     * @param   v   the value to be tested.\n     * @return  {@code true} if the value of the argument is positive\n     *          infinity or negative infinity; {@code false} otherwise.\n     */\n    public static boolean isInfinite(double v) {\n        return (v \u003d\u003d POSITIVE_INFINITY) || (v \u003d\u003d NEGATIVE_INFINITY);\n    }\n\n    /**\n     * Returns {@code true} if the argument is a finite floating-point\n     * value; returns {@code false} otherwise (for NaN and infinity\n     * arguments).\n     *\n     * @param d the {@code double} value to be tested\n     * @return {@code true} if the argument is a finite\n     * floating-point value, {@code false} otherwise.\n     * @since 1.8\n     */\n    public static boolean isFinite(double d) {\n        return Math.abs(d) \u003c\u003d Double.MAX_VALUE;\n    }\n\n    /**\n     * The value of the Double.\n     *\n     * @serial\n     */\n    private final double value;\n\n    /**\n     * Constructs a newly allocated {@code Double} object that\n     * represents the primitive {@code double} argument.\n     *\n     * @param   value   the value to be represented by the {@code Double}.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(double)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Double(double value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Double} object that\n     * represents the floating-point value of type {@code double}\n     * represented by the string. The string is converted to a\n     * {@code double} value as if by the {@code valueOf} method.\n     *\n     * @param  s  a string to be converted to a {@code Double}.\n     * @throws    NumberFormatException if the string does not contain a\n     *            parsable number.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseDouble(String)} to convert a string to a\n     * {@code double} primitive, or use {@link #valueOf(String)}\n     * to convert a string to a {@code Double} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Double(String s) throws NumberFormatException {\n        value \u003d parseDouble(s);\n    }\n\n    /**\n     * Returns {@code true} if this {@code Double} value is\n     * a Not-a-Number (NaN), {@code false} otherwise.\n     *\n     * @return  {@code true} if the value represented by this object is\n     *          NaN; {@code false} otherwise.\n     */\n    public boolean isNaN() {\n        return isNaN(value);\n    }\n\n    /**\n     * Returns {@code true} if this {@code Double} value is\n     * infinitely large in magnitude, {@code false} otherwise.\n     *\n     * @return  {@code true} if the value represented by this object is\n     *          positive infinity or negative infinity;\n     *          {@code false} otherwise.\n     */\n    public boolean isInfinite() {\n        return isInfinite(value);\n    }\n\n    /**\n     * Returns a string representation of this {@code Double} object.\n     * The primitive {@code double} value represented by this\n     * object is converted to a string exactly as if by the method\n     * {@code toString} of one argument.\n     *\n     * @return  a {@code String} representation of this object.\n     * @see java.lang.Double#toString(double)\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns the value of this {@code Double} as a {@code byte}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code byte}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     * @since 1.1\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Double} as a {@code short}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code short}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     * @since 1.1\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Double} as an {@code int}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code int}\n     */\n    public int intValue() {\n        return (int)value;\n    }\n\n    /**\n     * Returns the value of this {@code Double} as a {@code long}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code long}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Double} as a {@code float}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code float}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     * @since 1.0\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the {@code double} value of this {@code Double} object.\n     *\n     * @return the {@code double} value represented by this object\n     */\n    @IntrinsicCandidate\n    public double doubleValue() {\n        return value;\n    }\n\n    /**\n     * Returns a hash code for this {@code Double} object. The\n     * result is the exclusive OR of the two halves of the\n     * {@code long} integer bit representation, exactly as\n     * produced by the method {@link #doubleToLongBits(double)}, of\n     * the primitive {@code double} value represented by this\n     * {@code Double} object. That is, the hash code is the value\n     * of the expression:\n     *\n     * \u003cblockquote\u003e\n     *  {@code (int)(v^(v\u003e\u003e\u003e32))}\n     * \u003c/blockquote\u003e\n     *\n     * where {@code v} is defined by:\n     *\n     * \u003cblockquote\u003e\n     *  {@code long v \u003d Double.doubleToLongBits(this.doubleValue());}\n     * \u003c/blockquote\u003e\n     *\n     * @return  a {@code hash code} value for this object.\n     */\n    @Override\n    public int hashCode() {\n        return Double.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for a {@code double} value; compatible with\n     * {@code Double.hashCode()}.\n     *\n     * @param value the value to hash\n     * @return a hash code value for a {@code double} value.\n     * @since 1.8\n     */\n    public static int hashCode(double value) {\n        long bits \u003d doubleToLongBits(value);\n        return (int)(bits ^ (bits \u003e\u003e\u003e 32));\n    }\n\n    /**\n     * Compares this object against the specified object.  The result\n     * is {@code true} if and only if the argument is not\n     * {@code null} and is a {@code Double} object that\n     * represents a {@code double} that has the same value as the\n     * {@code double} represented by this object. For this\n     * purpose, two {@code double} values are considered to be\n     * the same if and only if the method {@link\n     * #doubleToLongBits(double)} returns the identical\n     * {@code long} value when applied to each.\n     *\n     * @apiNote\n     * This method is defined in terms of {@link\n     * #doubleToLongBits(double)} rather than the {@code \u003d\u003d} operator\n     * on {@code double} values since the {@code \u003d\u003d} operator does\n     * \u003cem\u003enot\u003c/em\u003e define an equivalence relation and to satisfy the\n     * {@linkplain Object#equals equals contract} an equivalence\n     * relation must be implemented; see \u003ca\n     * href\u003d\"#equivalenceRelation\"\u003ethis discussion\u003c/a\u003e for details of\n     * floating-point equality and equivalence.\n     *\n     * @see java.lang.Double#doubleToLongBits(double)\n     * @jls 15.21.1 Numerical Equality Operators \u003d\u003d and !\u003d\n     */\n    public boolean equals(Object obj) {\n        return (obj instanceof Double)\n               \u0026\u0026 (doubleToLongBits(((Double)obj).value) \u003d\u003d\n                      doubleToLongBits(value));\n    }\n\n    /**\n     * Returns a representation of the specified floating-point value\n     * according to the IEEE 754 floating-point \"double\n     * format\" bit layout.\n     *\n     * \u003cp\u003eBit 63 (the bit that is selected by the mask\n     * {@code 0x8000000000000000L}) represents the sign of the\n     * floating-point number. Bits\n     * 62-52 (the bits that are selected by the mask\n     * {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0\n     * (the bits that are selected by the mask\n     * {@code 0x000fffffffffffffL}) represent the significand\n     * (sometimes called the mantissa) of the floating-point number.\n     *\n     * \u003cp\u003eIf the argument is positive infinity, the result is\n     * {@code 0x7ff0000000000000L}.\n     *\n     * \u003cp\u003eIf the argument is negative infinity, the result is\n     * {@code 0xfff0000000000000L}.\n     *\n     * \u003cp\u003eIf the argument is NaN, the result is\n     * {@code 0x7ff8000000000000L}.\n     *\n     * \u003cp\u003eIn all cases, the result is a {@code long} integer that, when\n     * given to the {@link #longBitsToDouble(long)} method, will produce a\n     * floating-point value the same as the argument to\n     * {@code doubleToLongBits} (except all NaN values are\n     * collapsed to a single \"canonical\" NaN value).\n     *\n     * @param   value   a {@code double} precision floating-point number.\n     * @return the bits that represent the floating-point number.\n     */\n    @IntrinsicCandidate\n    public static long doubleToLongBits(double value) {\n        if (!isNaN(value)) {\n            return doubleToRawLongBits(value);\n        }\n        return 0x7ff8000000000000L;\n    }\n\n    /**\n     * Returns a representation of the specified floating-point value\n     * according to the IEEE 754 floating-point \"double\n     * format\" bit layout, preserving Not-a-Number (NaN) values.\n     *\n     * \u003cp\u003eBit 63 (the bit that is selected by the mask\n     * {@code 0x8000000000000000L}) represents the sign of the\n     * floating-point number. Bits\n     * 62-52 (the bits that are selected by the mask\n     * {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0\n     * (the bits that are selected by the mask\n     * {@code 0x000fffffffffffffL}) represent the significand\n     * (sometimes called the mantissa) of the floating-point number.\n     *\n     * \u003cp\u003eIf the argument is positive infinity, the result is\n     * {@code 0x7ff0000000000000L}.\n     *\n     * \u003cp\u003eIf the argument is negative infinity, the result is\n     * {@code 0xfff0000000000000L}.\n     *\n     * \u003cp\u003eIf the argument is NaN, the result is the {@code long}\n     * integer representing the actual NaN value.  Unlike the\n     * {@code doubleToLongBits} method,\n     * {@code doubleToRawLongBits} does not collapse all the bit\n     * patterns encoding a NaN to a single \"canonical\" NaN\n     * value.\n     *\n     * \u003cp\u003eIn all cases, the result is a {@code long} integer that,\n     * when given to the {@link #longBitsToDouble(long)} method, will\n     * produce a floating-point value the same as the argument to\n     * {@code doubleToRawLongBits}.\n     *\n     * @param   value   a {@code double} precision floating-point number.\n     * @return the bits that represent the floating-point number.\n     * @since 1.3\n     */\n    @IntrinsicCandidate\n    public static native long doubleToRawLongBits(double value);\n\n    /**\n     * Returns the {@code double} value corresponding to a given\n     * bit representation.\n     * The argument is considered to be a representation of a\n     * floating-point value according to the IEEE 754 floating-point\n     * \"double format\" bit layout.\n     *\n     * \u003cp\u003eIf the argument is {@code 0x7ff0000000000000L}, the result\n     * is positive infinity.\n     *\n     * \u003cp\u003eIf the argument is {@code 0xfff0000000000000L}, the result\n     * is negative infinity.\n     *\n     * \u003cp\u003eIf the argument is any value in the range\n     * {@code 0x7ff0000000000001L} through\n     * {@code 0x7fffffffffffffffL} or in the range\n     * {@code 0xfff0000000000001L} through\n     * {@code 0xffffffffffffffffL}, the result is a NaN.  No IEEE\n     * 754 floating-point operation provided by Java can distinguish\n     * between two NaN values of the same type with different bit\n     * patterns.  Distinct values of NaN are only distinguishable by\n     * use of the {@code Double.doubleToRawLongBits} method.\n     *\n     * \u003cp\u003eIn all other cases, let \u003ci\u003es\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, and \u003ci\u003em\u003c/i\u003e be three\n     * values that can be computed from the argument:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e{@code\n     * int s \u003d ((bits \u003e\u003e 63) \u003d\u003d 0) ? 1 : -1;\n     * int e \u003d (int)((bits \u003e\u003e 52) \u0026 0x7ffL);\n     * long m \u003d (e \u003d\u003d 0) ?\n     *                 (bits \u0026 0xfffffffffffffL) \u003c\u003c 1 :\n     *                 (bits \u0026 0xfffffffffffffL) | 0x10000000000000L;\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Then the floating-point result equals the value of the mathematical\n     * expression \u003ci\u003es\u003c/i\u003e\u0026middot;\u003ci\u003em\u003c/i\u003e\u0026middot;2\u003csup\u003e\u003ci\u003ee\u003c/i\u003e-1075\u003c/sup\u003e.\n     *\n     * \u003cp\u003eNote that this method may not be able to return a\n     * {@code double} NaN with exactly same bit pattern as the\n     * {@code long} argument.  IEEE 754 distinguishes between two\n     * kinds of NaNs, quiet NaNs and \u003ci\u003esignaling NaNs\u003c/i\u003e.  The\n     * differences between the two kinds of NaN are generally not\n     * visible in Java.  Arithmetic operations on signaling NaNs turn\n     * them into quiet NaNs with a different, but often similar, bit\n     * pattern.  However, on some processors merely copying a\n     * signaling NaN also performs that conversion.  In particular,\n     * copying a signaling NaN to return it to the calling method\n     * may perform this conversion.  So {@code longBitsToDouble}\n     * may not be able to return a {@code double} with a\n     * signaling NaN bit pattern.  Consequently, for some\n     * {@code long} values,\n     * {@code doubleToRawLongBits(longBitsToDouble(start))} may\n     * \u003ci\u003enot\u003c/i\u003e equal {@code start}.  Moreover, which\n     * particular bit patterns represent signaling NaNs is platform\n     * dependent; although all NaN bit patterns, quiet or signaling,\n     * must be in the NaN range identified above.\n     *\n     * @param   bits   any {@code long} integer.\n     * @return  the {@code double} floating-point value with the same\n     *          bit pattern.\n     */\n    @IntrinsicCandidate\n    public static native double longBitsToDouble(long bits);\n\n    /**\n     * Compares two {@code Double} objects numerically.\n     *\n     * This method imposes a total order on {@code Double} objects\n     * with two differences compared to the incomplete order defined by\n     * the Java language numerical comparison operators ({@code \u003c, \u003c\u003d,\n     * \u003d\u003d, \u003e\u003d, \u003e}) on {@code double} values.\n     *\n     * \u003cul\u003e\u003cli\u003e A NaN is \u003cem\u003eunordered\u003c/em\u003e with respect to other\n     *          values and unequal to itself under the comparison\n     *          operators.  This method chooses to define {@code\n     *          Double.NaN} to be equal to itself and greater than all\n     *          other {@code double} values (including {@code\n     *          Double.POSITIVE_INFINITY}).\n     *\n     *      \u003cli\u003e Positive zero and negative zero compare equal\n     *      numerically, but are distinct and distinguishable values.\n     *      This method chooses to define positive zero ({@code +0.0d}),\n     *      to be greater than negative zero ({@code -0.0d}).\n     * \u003c/ul\u003e\n\n     * This ensures that the \u003ci\u003enatural ordering\u003c/i\u003e of {@code Double}\n     * objects imposed by this method is \u003ci\u003econsistent with\n     * equals\u003c/i\u003e; see \u003ca href\u003d\"#equivalenceRelation\"\u003ethis\n     * discussion\u003c/a\u003e for details of floating-point comparison and\n     * ordering.\n     *\n     * @param   anotherDouble   the {@code Double} to be compared.\n     * @return  the value {@code 0} if {@code anotherDouble} is\n     *          numerically equal to this {@code Double}; a value\n     *          less than {@code 0} if this {@code Double}\n     *          is numerically less than {@code anotherDouble};\n     *          and a value greater than {@code 0} if this\n     *          {@code Double} is numerically greater than\n     *          {@code anotherDouble}.\n     *\n     * @jls 15.20.1 Numerical Comparison Operators {@code \u003c}, {@code \u003c\u003d}, {@code \u003e}, and {@code \u003e\u003d}\n     * @since   1.2\n     */\n    public int compareTo(Double anotherDouble) {\n        return Double.compare(value, anotherDouble.value);\n    }\n\n    /**\n     * Compares the two specified {@code double} values. The sign\n     * of the integer value returned is the same as that of the\n     * integer that would be returned by the call:\n     * \u003cpre\u003e\n     *    new Double(d1).compareTo(new Double(d2))\n     * \u003c/pre\u003e\n     *\n     * @param   d1        the first {@code double} to compare\n     * @param   d2        the second {@code double} to compare\n     * @return  the value {@code 0} if {@code d1} is\n     *          numerically equal to {@code d2}; a value less than\n     *          {@code 0} if {@code d1} is numerically less than\n     *          {@code d2}; and a value greater than {@code 0}\n     *          if {@code d1} is numerically greater than\n     *          {@code d2}.\n     * @since 1.4\n     */\n    public static int compare(double d1, double d2) {\n        if (d1 \u003c d2)\n            return -1;           // Neither val is NaN, thisVal is smaller\n        if (d1 \u003e d2)\n            return 1;            // Neither val is NaN, thisVal is larger\n\n        // Cannot use doubleToRawLongBits because of possibility of NaNs.\n        long thisBits    \u003d Double.doubleToLongBits(d1);\n        long anotherBits \u003d Double.doubleToLongBits(d2);\n\n        return (thisBits \u003d\u003d anotherBits ?  0 : // Values are equal\n                (thisBits \u003c anotherBits ? -1 : // (-0.0, 0.0) or (!NaN, NaN)\n                 1));                          // (0.0, -0.0) or (NaN, !NaN)\n    }\n\n    /**\n     * Adds two {@code double} values together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @jls 4.2.4 Floating-Point Operations\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static double sum(double a, double b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code double} values\n     * as if by calling {@link Math#max(double, double) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static double max(double a, double b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code double} values\n     * as if by calling {@link Math#min(double, double) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}.\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static double min(double a, double b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Double} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cDouble\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Double} instance\n     * @since 12\n     */\n    @Override\n    public Double resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -9172774392245257468L;\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Double.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Double.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Jan 09, 2024 9:52:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17.0.8.1%2B1/lib/src.zip%21/java.base/java/lang/Double.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Double.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Double.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.01.09 09:52:37 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 09:52:48 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1+1/lib/src.zip!/java.base/java/lang/Double.java

Uri: jar:file:///C:/Program Files/Java/jdk-17.0.8.1+1/lib/src.zip!/java.base/java/lang/Double.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:667)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

Jan 09, 2024 9:52:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17.0.8.1%2B1/lib/src.zip%21/java.base/java/lang/Double.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Optional;\n\nimport jdk.internal.math.FloatingDecimal;\nimport jdk.internal.math.DoubleConsts;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\n/**\n * The {@code Double} class wraps a value of the primitive type\n * {@code double} in an object. An object of type\n * {@code Double} contains a single field whose type is\n * {@code double}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting a\n * {@code double} to a {@code String} and a\n * {@code String} to a {@code double}, as well as other\n * constants and methods useful when dealing with a\n * {@code double}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003ch2\u003e\u003ca id\u003dequivalenceRelation\u003eFloating-point Equality, Equivalence,\n * and Comparison\u003c/a\u003e\u003c/h2\u003e\n *\n * IEEE 754 floating-point values include finite nonzero values,\n * signed zeros ({@code +0.0} and {@code -0.0}), signed infinities\n * {@linkplain Double#POSITIVE_INFINITY positive infinity} and\n * {@linkplain Double#NEGATIVE_INFINITY negative infinity}), and\n * {@linkplain Double#NaN NaN} (not-a-number).\n *\n * \u003cp\u003eAn \u003cem\u003eequivalence relation\u003c/em\u003e on a set of values is a boolean\n * relation on pairs of values that is reflexive, symmetric, and\n * transitive. For more discussion of equivalence relations and object\n * equality, see the {@link Object#equals Object.equals}\n * specification. An equivalence relation partitions the values it\n * operates over into sets called \u003ci\u003eequivalence classes\u003c/i\u003e.  All the\n * members of the equivalence class are equal to each other under the\n * relation. An equivalence class may contain only a single member. At\n * least for some purposes, all the members of an equivalence class\n * are substitutable for each other.  In particular, in a numeric\n * expression equivalent values can be \u003cem\u003esubstituted\u003c/em\u003e for one\n * another without changing the result of the expression, meaning\n * changing the equivalence class of the result of the expression.\n *\n * \u003cp\u003eNotably, the built-in {@code \u003d\u003d} operation on floating-point\n * values is \u003cem\u003enot\u003c/em\u003e an equivalence relation. Despite not\n * defining an equivalence relation, the semantics of the IEEE 754\n * {@code \u003d\u003d} operator were deliberately designed to meet other needs\n * of numerical computation. There are two exceptions where the\n * properties of an equivalence relation are not satisfied by {@code\n * \u003d\u003d} on floating-point values:\n *\n * \u003cul\u003e\n *\n * \u003cli\u003eIf {@code v1} and {@code v2} are both NaN, then {@code v1\n * \u003d\u003d v2} has the value {@code false}. Therefore, for two NaN\n * arguments the \u003cem\u003ereflexive\u003c/em\u003e property of an equivalence\n * relation is \u003cem\u003enot\u003c/em\u003e satisfied by the {@code \u003d\u003d} operator.\n *\n * \u003cli\u003eIf {@code v1} represents {@code +0.0} while {@code v2}\n * represents {@code -0.0}, or vice versa, then {@code v1 \u003d\u003d v2} has\n * the value {@code true} even though {@code +0.0} and {@code -0.0}\n * are distinguishable under various floating-point operations. For\n * example, {@code 1.0/+0.0} evaluates to positive infinity while\n * {@code 1.0/-0.0} evaluates to \u003cem\u003enegative\u003c/em\u003e infinity and\n * positive infinity and negative infinity are neither equal to each\n * other nor equivalent to each other. Thus, while a signed zero input\n * most commonly determines the sign of a zero result, because of\n * dividing by zero, {@code +0.0} and {@code -0.0} may not be\n * substituted for each other in general. The sign of a zero input\n * also has a non-substitutable effect on the result of some math\n * library methods.\n *\n * \u003c/ul\u003e\n *\n * \u003cp\u003eFor ordered comparisons using the built-in comparison operators\n * ({@code \u003c}, {@code \u003c\u003d}, etc.), NaN values have another anomalous\n * situation: a NaN is neither less than, nor greater than, nor equal\n * to any value, including itself. This means the \u003ci\u003etrichotomy of\n * comparison\u003c/i\u003e does \u003cem\u003enot\u003c/em\u003e hold.\n *\n * \u003cp\u003eTo provide the appropriate semantics for {@code equals} and\n * {@code compareTo} methods, those methods cannot simply be wrappers\n * around {@code \u003d\u003d} or ordered comparison operations. Instead, {@link\n * Double#equals equals} defines NaN arguments to be equal to each\n * other and defines {@code +0.0} to \u003cem\u003enot\u003c/em\u003e be equal to {@code\n * -0.0}, restoring reflexivity. For comparisons, {@link\n * Double#compareTo compareTo} defines a total order where {@code\n * -0.0} is less than {@code +0.0} and where a NaN is equal to itself\n * and considered greater than positive infinity.\n *\n * \u003cp\u003eThe operational semantics of {@code equals} and {@code\n * compareTo} are expressed in terms of {@linkplain #doubleToLongBits\n * bit-wise converting} the floating-point values to integral values.\n *\n * \u003cp\u003eThe \u003cem\u003enatural ordering\u003c/em\u003e implemented by {@link #compareTo\n * compareTo} is {@linkplain Comparable consistent with equals}. That\n * is, two objects are reported as equal by {@code equals} if and only\n * if {@code compareTo} on those objects returns zero.\n *\n * \u003cp\u003eThe adjusted behaviors defined for {@code equals} and {@code\n * compareTo} allow instances of wrapper classes to work properly with\n * conventional data structures. For example, defining NaN\n * values to be {@code equals} to one another allows NaN to be used as\n * an element of a {@link java.util.HashSet HashSet} or as the key of\n * a {@link java.util.HashMap HashMap}. Similarly, defining {@code\n * compareTo} as a total ordering, including {@code +0.0}, {@code\n * -0.0}, and NaN, allows instances of wrapper classes to be used as\n * elements of a {@link java.util.SortedSet SortedSet} or as keys of a\n * {@link java.util.SortedMap SortedMap}.\n *\n * @jls 4.2.3 Floating-Point Types, Formats, and Values\n * @jls 4.2.4. Floating-Point Operations\n * @jls 15.21.1 Numerical Equality Operators \u003d\u003d and !\u003d\n * @jls 15.20.1 Numerical Comparison Operators {@code \u003c}, {@code \u003c\u003d}, {@code \u003e}, and {@code \u003e\u003d}\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Double extends Number\n        implements Comparable\u003cDouble\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the positive infinity of type\n     * {@code double}. It is equal to the value returned by\n     * {@code Double.longBitsToDouble(0x7ff0000000000000L)}.\n     */\n    public static final double POSITIVE_INFINITY \u003d 1.0 / 0.0;\n\n    /**\n     * A constant holding the negative infinity of type\n     * {@code double}. It is equal to the value returned by\n     * {@code Double.longBitsToDouble(0xfff0000000000000L)}.\n     */\n    public static final double NEGATIVE_INFINITY \u003d -1.0 / 0.0;\n\n    /**\n     * A constant holding a Not-a-Number (NaN) value of type\n     * {@code double}. It is equivalent to the value returned by\n     * {@code Double.longBitsToDouble(0x7ff8000000000000L)}.\n     */\n    public static final double NaN \u003d 0.0d / 0.0;\n\n    /**\n     * A constant holding the largest positive finite value of type\n     * {@code double},\n     * (2-2\u003csup\u003e-52\u003c/sup\u003e)\u0026middot;2\u003csup\u003e1023\u003c/sup\u003e.  It is equal to\n     * the hexadecimal floating-point literal\n     * {@code 0x1.fffffffffffffP+1023} and also equal to\n     * {@code Double.longBitsToDouble(0x7fefffffffffffffL)}.\n     */\n    public static final double MAX_VALUE \u003d 0x1.fffffffffffffP+1023; // 1.7976931348623157e+308\n\n    /**\n     * A constant holding the smallest positive normal value of type\n     * {@code double}, 2\u003csup\u003e-1022\u003c/sup\u003e.  It is equal to the\n     * hexadecimal floating-point literal {@code 0x1.0p-1022} and also\n     * equal to {@code Double.longBitsToDouble(0x0010000000000000L)}.\n     *\n     * @since 1.6\n     */\n    public static final double MIN_NORMAL \u003d 0x1.0p-1022; // 2.2250738585072014E-308\n\n    /**\n     * A constant holding the smallest positive nonzero value of type\n     * {@code double}, 2\u003csup\u003e-1074\u003c/sup\u003e. It is equal to the\n     * hexadecimal floating-point literal\n     * {@code 0x0.0000000000001P-1022} and also equal to\n     * {@code Double.longBitsToDouble(0x1L)}.\n     */\n    public static final double MIN_VALUE \u003d 0x0.0000000000001P-1022; // 4.9e-324\n\n    /**\n     * Maximum exponent a finite {@code double} variable may have.\n     * It is equal to the value returned by\n     * {@code Math.getExponent(Double.MAX_VALUE)}.\n     *\n     * @since 1.6\n     */\n    public static final int MAX_EXPONENT \u003d 1023;\n\n    /**\n     * Minimum exponent a normalized {@code double} variable may\n     * have.  It is equal to the value returned by\n     * {@code Math.getExponent(Double.MIN_NORMAL)}.\n     *\n     * @since 1.6\n     */\n    public static final int MIN_EXPONENT \u003d -1022;\n\n    /**\n     * The number of bits used to represent a {@code double} value.\n     *\n     * @since 1.5\n     */\n    public static final int SIZE \u003d 64;\n\n    /**\n     * The number of bytes used to represent a {@code double} value.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code double}.\n     *\n     * @since 1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cDouble\u003e   TYPE \u003d (Class\u003cDouble\u003e) Class.getPrimitiveClass(\"double\");\n\n    /**\n     * Returns a string representation of the {@code double}\n     * argument. All characters mentioned below are ASCII characters.\n     * \u003cul\u003e\n     * \u003cli\u003eIf the argument is NaN, the result is the string\n     *     \"{@code NaN}\".\n     * \u003cli\u003eOtherwise, the result is a string that represents the sign and\n     * magnitude (absolute value) of the argument. If the sign is negative,\n     * the first character of the result is \u0027{@code -}\u0027\n     * ({@code \u0027\\u005Cu002D\u0027}); if the sign is positive, no sign character\n     * appears in the result. As for the magnitude \u003ci\u003em\u003c/i\u003e:\n     * \u003cul\u003e\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is infinity, it is represented by the characters\n     * {@code \"Infinity\"}; thus, positive infinity produces the result\n     * {@code \"Infinity\"} and negative infinity produces the result\n     * {@code \"-Infinity\"}.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is zero, it is represented by the characters\n     * {@code \"0.0\"}; thus, negative zero produces the result\n     * {@code \"-0.0\"} and positive zero produces the result\n     * {@code \"0.0\"}.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is greater than or equal to 10\u003csup\u003e-3\u003c/sup\u003e but less\n     * than 10\u003csup\u003e7\u003c/sup\u003e, then it is represented as the integer part of\n     * \u003ci\u003em\u003c/i\u003e, in decimal form with no leading zeroes, followed by\n     * \u0027{@code .}\u0027 ({@code \u0027\\u005Cu002E\u0027}), followed by one or\n     * more decimal digits representing the fractional part of \u003ci\u003em\u003c/i\u003e.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is less than 10\u003csup\u003e-3\u003c/sup\u003e or greater than or\n     * equal to 10\u003csup\u003e7\u003c/sup\u003e, then it is represented in so-called\n     * \"computerized scientific notation.\" Let \u003ci\u003en\u003c/i\u003e be the unique\n     * integer such that 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e \u0026le; \u003ci\u003em\u003c/i\u003e {@literal \u003c}\n     * 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e+1\u003c/sup\u003e; then let \u003ci\u003ea\u003c/i\u003e be the\n     * mathematically exact quotient of \u003ci\u003em\u003c/i\u003e and\n     * 10\u003csup\u003e\u003ci\u003en\u003c/i\u003e\u003c/sup\u003e so that 1 \u0026le; \u003ci\u003ea\u003c/i\u003e {@literal \u003c} 10. The\n     * magnitude is then represented as the integer part of \u003ci\u003ea\u003c/i\u003e,\n     * as a single decimal digit, followed by \u0027{@code .}\u0027\n     * ({@code \u0027\\u005Cu002E\u0027}), followed by decimal digits\n     * representing the fractional part of \u003ci\u003ea\u003c/i\u003e, followed by the\n     * letter \u0027{@code E}\u0027 ({@code \u0027\\u005Cu0045\u0027}), followed\n     * by a representation of \u003ci\u003en\u003c/i\u003e as a decimal integer, as\n     * produced by the method {@link Integer#toString(int)}.\n     * \u003c/ul\u003e\n     * \u003c/ul\u003e\n     * How many digits must be printed for the fractional part of\n     * \u003ci\u003em\u003c/i\u003e or \u003ci\u003ea\u003c/i\u003e? There must be at least one digit to represent\n     * the fractional part, and beyond that as many, but only as many, more\n     * digits as are needed to uniquely distinguish the argument value from\n     * adjacent values of type {@code double}. That is, suppose that\n     * \u003ci\u003ex\u003c/i\u003e is the exact mathematical value represented by the decimal\n     * representation produced by this method for a finite nonzero argument\n     * \u003ci\u003ed\u003c/i\u003e. Then \u003ci\u003ed\u003c/i\u003e must be the {@code double} value nearest\n     * to \u003ci\u003ex\u003c/i\u003e; or if two {@code double} values are equally close\n     * to \u003ci\u003ex\u003c/i\u003e, then \u003ci\u003ed\u003c/i\u003e must be one of them and the least\n     * significant bit of the significand of \u003ci\u003ed\u003c/i\u003e must be {@code 0}.\n     *\n     * \u003cp\u003eTo create localized string representations of a floating-point\n     * value, use subclasses of {@link java.text.NumberFormat}.\n     *\n     * @param   d   the {@code double} to be converted.\n     * @return a string representation of the argument.\n     */\n    public static String toString(double d) {\n        return FloatingDecimal.toJavaFormatString(d);\n    }\n\n    /**\n     * Returns a hexadecimal string representation of the\n     * {@code double} argument. All characters mentioned below\n     * are ASCII characters.\n     *\n     * \u003cul\u003e\n     * \u003cli\u003eIf the argument is NaN, the result is the string\n     *     \"{@code NaN}\".\n     * \u003cli\u003eOtherwise, the result is a string that represents the sign\n     * and magnitude of the argument. If the sign is negative, the\n     * first character of the result is \u0027{@code -}\u0027\n     * ({@code \u0027\\u005Cu002D\u0027}); if the sign is positive, no sign\n     * character appears in the result. As for the magnitude \u003ci\u003em\u003c/i\u003e:\n     *\n     * \u003cul\u003e\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is infinity, it is represented by the string\n     * {@code \"Infinity\"}; thus, positive infinity produces the\n     * result {@code \"Infinity\"} and negative infinity produces\n     * the result {@code \"-Infinity\"}.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is zero, it is represented by the string\n     * {@code \"0x0.0p0\"}; thus, negative zero produces the result\n     * {@code \"-0x0.0p0\"} and positive zero produces the result\n     * {@code \"0x0.0p0\"}.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is a {@code double} value with a\n     * normalized representation, substrings are used to represent the\n     * significand and exponent fields.  The significand is\n     * represented by the characters {@code \"0x1.\"}\n     * followed by a lowercase hexadecimal representation of the rest\n     * of the significand as a fraction.  Trailing zeros in the\n     * hexadecimal representation are removed unless all the digits\n     * are zero, in which case a single zero is used. Next, the\n     * exponent is represented by {@code \"p\"} followed\n     * by a decimal string of the unbiased exponent as if produced by\n     * a call to {@link Integer#toString(int) Integer.toString} on the\n     * exponent value.\n     *\n     * \u003cli\u003eIf \u003ci\u003em\u003c/i\u003e is a {@code double} value with a subnormal\n     * representation, the significand is represented by the\n     * characters {@code \"0x0.\"} followed by a\n     * hexadecimal representation of the rest of the significand as a\n     * fraction.  Trailing zeros in the hexadecimal representation are\n     * removed. Next, the exponent is represented by\n     * {@code \"p-1022\"}.  Note that there must be at\n     * least one nonzero digit in a subnormal significand.\n     *\n     * \u003c/ul\u003e\n     *\n     * \u003c/ul\u003e\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption\u003eExamples\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eFloating-point Value\u003c/th\u003e\u003cth scope\u003d\"col\"\u003eHexadecimal String\u003c/th\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody style\u003d\"text-align:right\"\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code 1.0}\u003c/th\u003e \u003ctd\u003e{@code 0x1.0p0}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code -1.0}\u003c/th\u003e        \u003ctd\u003e{@code -0x1.0p0}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code 2.0}\u003c/th\u003e \u003ctd\u003e{@code 0x1.0p1}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code 3.0}\u003c/th\u003e \u003ctd\u003e{@code 0x1.8p1}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code 0.5}\u003c/th\u003e \u003ctd\u003e{@code 0x1.0p-1}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code 0.25}\u003c/th\u003e        \u003ctd\u003e{@code 0x1.0p-2}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code Double.MAX_VALUE}\u003c/th\u003e\n     *     \u003ctd\u003e{@code 0x1.fffffffffffffp1023}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code Minimum Normal Value}\u003c/th\u003e\n     *     \u003ctd\u003e{@code 0x1.0p-1022}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code Maximum Subnormal Value}\u003c/th\u003e\n     *     \u003ctd\u003e{@code 0x0.fffffffffffffp-1022}\u003c/td\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code Double.MIN_VALUE}\u003c/th\u003e\n     *     \u003ctd\u003e{@code 0x0.0000000000001p-1022}\u003c/td\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param   d   the {@code double} to be converted.\n     * @return a hex string representation of the argument.\n     * @since 1.5\n     * @author Joseph D. Darcy\n     */\n    public static String toHexString(double d) {\n        /*\n         * Modeled after the \"a\" conversion specifier in C99, section\n         * 7.19.6.1; however, the output of this method is more\n         * tightly specified.\n         */\n        if (!isFinite(d) )\n            // For infinity and NaN, use the decimal output.\n            return Double.toString(d);\n        else {\n            // Initialized to maximum size of output.\n            StringBuilder answer \u003d new StringBuilder(24);\n\n            if (Math.copySign(1.0, d) \u003d\u003d -1.0)    // value is negative,\n                answer.append(\"-\");                  // so append sign info\n\n            answer.append(\"0x\");\n\n            d \u003d Math.abs(d);\n\n            if(d \u003d\u003d 0.0) {\n                answer.append(\"0.0p0\");\n            } else {\n                boolean subnormal \u003d (d \u003c Double.MIN_NORMAL);\n\n                // Isolate significand bits and OR in a high-order bit\n                // so that the string representation has a known\n                // length.\n                long signifBits \u003d (Double.doubleToLongBits(d)\n                                   \u0026 DoubleConsts.SIGNIF_BIT_MASK) |\n                    0x1000000000000000L;\n\n                // Subnormal values have a 0 implicit bit; normal\n                // values have a 1 implicit bit.\n                answer.append(subnormal ? \"0.\" : \"1.\");\n\n                // Isolate the low-order 13 digits of the hex\n                // representation.  If all the digits are zero,\n                // replace with a single 0; otherwise, remove all\n                // trailing zeros.\n                String signif \u003d Long.toHexString(signifBits).substring(3,16);\n                answer.append(signif.equals(\"0000000000000\") ? // 13 zeros\n                              \"0\":\n                              signif.replaceFirst(\"0{1,12}$\", \"\"));\n\n                answer.append(\u0027p\u0027);\n                // If the value is subnormal, use the E_min exponent\n                // value for double; otherwise, extract and report d\u0027s\n                // exponent (the representation of a subnormal uses\n                // E_min -1).\n                answer.append(subnormal ?\n                              Double.MIN_EXPONENT:\n                              Math.getExponent(d));\n            }\n            return answer.toString();\n        }\n    }\n\n    /**\n     * Returns a {@code Double} object holding the\n     * {@code double} value represented by the argument string\n     * {@code s}.\n     *\n     * \u003cp\u003eIf {@code s} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     *\n     * \u003cp\u003eLeading and trailing whitespace characters in {@code s}\n     * are ignored.  Whitespace is removed as if by the {@link\n     * String#trim} method; that is, both ASCII space and control\n     * characters are removed. The rest of {@code s} should\n     * constitute a \u003ci\u003eFloatValue\u003c/i\u003e as described by the lexical\n     * syntax rules:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eFloatValue:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code NaN}\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code Infinity}\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e FloatingPointLiteral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e HexFloatingPointLiteral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSignedInteger\u003c/i\u003e\n     * \u003c/dl\u003e\n     *\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eHexFloatingPointLiteral\u003c/i\u003e:\n     * \u003cdd\u003e \u003ci\u003eHexSignificand BinaryExponent FloatTypeSuffix\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e\n     * \u003c/dl\u003e\n     *\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eHexSignificand:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eHexNumeral\u003c/i\u003e {@code .}\n     * \u003cdd\u003e{@code 0x} \u003ci\u003eHexDigits\u003csub\u003eopt\u003c/sub\u003e\n     *     \u003c/i\u003e{@code .}\u003ci\u003e HexDigits\u003c/i\u003e\n     * \u003cdd\u003e{@code 0X}\u003ci\u003e HexDigits\u003csub\u003eopt\u003c/sub\u003e\n     *     \u003c/i\u003e{@code .} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003c/dl\u003e\n     *\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eBinaryExponent:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eBinaryExponentIndicator SignedInteger\u003c/i\u003e\n     * \u003c/dl\u003e\n     *\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eBinaryExponentIndicator:\u003c/i\u003e\n     * \u003cdd\u003e{@code p}\n     * \u003cdd\u003e{@code P}\n     * \u003c/dl\u003e\n     *\n     * \u003c/blockquote\u003e\n     *\n     * where \u003ci\u003eSign\u003c/i\u003e, \u003ci\u003eFloatingPointLiteral\u003c/i\u003e,\n     * \u003ci\u003eHexNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, \u003ci\u003eSignedInteger\u003c/i\u003e and\n     * \u003ci\u003eFloatTypeSuffix\u003c/i\u003e are as defined in the lexical structure\n     * sections of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     * If {@code s} does not have the form of\n     * a \u003ci\u003eFloatValue\u003c/i\u003e, then a {@code NumberFormatException}\n     * is thrown. Otherwise, {@code s} is regarded as\n     * representing an exact decimal value in the usual\n     * \"computerized scientific notation\" or as an exact\n     * hexadecimal value; this exact numerical value is then\n     * conceptually converted to an \"infinitely precise\"\n     * binary value that is then rounded to type {@code double}\n     * by the usual round-to-nearest rule of IEEE 754 floating-point\n     * arithmetic, which includes preserving the sign of a zero\n     * value.\n     *\n     * Note that the round-to-nearest rule also implies overflow and\n     * underflow behaviour; if the exact value of {@code s} is large\n     * enough in magnitude (greater than or equal to ({@link\n     * #MAX_VALUE} + {@link Math#ulp(double) ulp(MAX_VALUE)}/2),\n     * rounding to {@code double} will result in an infinity and if the\n     * exact value of {@code s} is small enough in magnitude (less\n     * than or equal to {@link #MIN_VALUE}/2), rounding to float will\n     * result in a zero.\n     *\n     * Finally, after rounding a {@code Double} object representing\n     * this {@code double} value is returned.\n     *\n     * \u003cp\u003e To interpret localized string representations of a\n     * floating-point value, use subclasses of {@link\n     * java.text.NumberFormat}.\n     *\n     * \u003cp\u003eNote that trailing format specifiers, specifiers that\n     * determine the type of a floating-point literal\n     * ({@code 1.0f} is a {@code float} value;\n     * {@code 1.0d} is a {@code double} value), do\n     * \u003cem\u003enot\u003c/em\u003e influence the results of this method.  In other\n     * words, the numerical value of the input string is converted\n     * directly to the target floating-point type.  The two-step\n     * sequence of conversions, string to {@code float} followed\n     * by {@code float} to {@code double}, is \u003cem\u003enot\u003c/em\u003e\n     * equivalent to converting a string directly to\n     * {@code double}. For example, the {@code float}\n     * literal {@code 0.1f} is equal to the {@code double}\n     * value {@code 0.10000000149011612}; the {@code float}\n     * literal {@code 0.1f} represents a different numerical\n     * value than the {@code double} literal\n     * {@code 0.1}. (The numerical value 0.1 cannot be exactly\n     * represented in a binary floating-point number.)\n     *\n     * \u003cp\u003eTo avoid calling this method on an invalid string and having\n     * a {@code NumberFormatException} be thrown, the regular\n     * expression below can be used to screen the input string:\n     *\n     * \u003cpre\u003e{@code\n     *  final String Digits     \u003d \"(\\\\p{Digit}+)\";\n     *  final String HexDigits  \u003d \"(\\\\p{XDigit}+)\";\n     *  // an exponent is \u0027e\u0027 or \u0027E\u0027 followed by an optionally\n     *  // signed decimal integer.\n     *  final String Exp        \u003d \"[eE][+-]?\"+Digits;\n     *  final String fpRegex    \u003d\n     *      (\"[\\\\x00-\\\\x20]*\"+  // Optional leading \"whitespace\"\n     *       \"[+-]?(\" + // Optional sign character\n     *       \"NaN|\" +           // \"NaN\" string\n     *       \"Infinity|\" +      // \"Infinity\" string\n     *\n     *       // A decimal floating-point string representing a finite positive\n     *       // number without a leading sign has at most five basic pieces:\n     *       // Digits . Digits ExponentPart FloatTypeSuffix\n     *       //\n     *       // Since this method allows integer-only strings as input\n     *       // in addition to strings of floating-point literals, the\n     *       // two sub-patterns below are simplifications of the grammar\n     *       // productions from section 3.10.2 of\n     *       // The Java Language Specification.\n     *\n     *       // Digits ._opt Digits_opt ExponentPart_opt FloatTypeSuffix_opt\n     *       \"(((\"+Digits+\"(\\\\.)?(\"+Digits+\"?)(\"+Exp+\")?)|\"+\n     *\n     *       // . Digits ExponentPart_opt FloatTypeSuffix_opt\n     *       \"(\\\\.(\"+Digits+\")(\"+Exp+\")?)|\"+\n     *\n     *       // Hexadecimal strings\n     *       \"((\" +\n     *        // 0[xX] HexDigits ._opt BinaryExponent FloatTypeSuffix_opt\n     *        \"(0[xX]\" + HexDigits + \"(\\\\.)?)|\" +\n     *\n     *        // 0[xX] HexDigits_opt . HexDigits BinaryExponent FloatTypeSuffix_opt\n     *        \"(0[xX]\" + HexDigits + \"?(\\\\.)\" + HexDigits + \")\" +\n     *\n     *        \")[pP][+-]?\" + Digits + \"))\" +\n     *       \"[fFdD]?))\" +\n     *       \"[\\\\x00-\\\\x20]*\");// Optional trailing \"whitespace\"\n     *\n     *  if (Pattern.matches(fpRegex, myString))\n     *      Double.valueOf(myString); // Will not throw NumberFormatException\n     *  else {\n     *      // Perform suitable alternative action\n     *  }\n     * }\u003c/pre\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     a {@code Double} object holding the value\n     *             represented by the {@code String} argument.\n     * @throws     NumberFormatException  if the string does not contain a\n     *             parsable number.\n     */\n    public static Double valueOf(String s) throws NumberFormatException {\n        return new Double(parseDouble(s));\n    }\n\n    /**\n     * Returns a {@code Double} instance representing the specified\n     * {@code double} value.\n     * If a new {@code Double} instance is not required, this method\n     * should generally be used in preference to the constructor\n     * {@link #Double(double)}, as this method is likely to yield\n     * significantly better space and time performance by caching\n     * frequently requested values.\n     *\n     * @param  d a double value.\n     * @return a {@code Double} instance representing {@code d}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Double valueOf(double d) {\n        return new Double(d);\n    }\n\n    /**\n     * Returns a new {@code double} initialized to the value\n     * represented by the specified {@code String}, as performed\n     * by the {@code valueOf} method of class\n     * {@code Double}.\n     *\n     * @param  s   the string to be parsed.\n     * @return the {@code double} value represented by the string\n     *         argument.\n     * @throws NullPointerException  if the string is null\n     * @throws NumberFormatException if the string does not contain\n     *         a parsable {@code double}.\n     * @see    java.lang.Double#valueOf(String)\n     * @since 1.2\n     */\n    public static double parseDouble(String s) throws NumberFormatException {\n        return FloatingDecimal.parseDouble(s);\n    }\n\n    /**\n     * Returns {@code true} if the specified number is a\n     * Not-a-Number (NaN) value, {@code false} otherwise.\n     *\n     * @param   v   the value to be tested.\n     * @return  {@code true} if the value of the argument is NaN;\n     *          {@code false} otherwise.\n     */\n    public static boolean isNaN(double v) {\n        return (v !\u003d v);\n    }\n\n    /**\n     * Returns {@code true} if the specified number is infinitely\n     * large in magnitude, {@code false} otherwise.\n     *\n     * @param   v   the value to be tested.\n     * @return  {@code true} if the value of the argument is positive\n     *          infinity or negative infinity; {@code false} otherwise.\n     */\n    public static boolean isInfinite(double v) {\n        return (v \u003d\u003d POSITIVE_INFINITY) || (v \u003d\u003d NEGATIVE_INFINITY);\n    }\n\n    /**\n     * Returns {@code true} if the argument is a finite floating-point\n     * value; returns {@code false} otherwise (for NaN and infinity\n     * arguments).\n     *\n     * @param d the {@code double} value to be tested\n     * @return {@code true} if the argument is a finite\n     * floating-point value, {@code false} otherwise.\n     * @since 1.8\n     */\n    public static boolean isFinite(double d) {\n        return Math.abs(d) \u003c\u003d Double.MAX_VALUE;\n    }\n\n    /**\n     * The value of the Double.\n     *\n     * @serial\n     */\n    private final double value;\n\n    /**\n     * Constructs a newly allocated {@code Double} object that\n     * represents the primitive {@code double} argument.\n     *\n     * @param   value   the value to be represented by the {@code Double}.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(double)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Double(double value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Double} object that\n     * represents the floating-point value of type {@code double}\n     * represented by the string. The string is converted to a\n     * {@code double} value as if by the {@code valueOf} method.\n     *\n     * @param  s  a string to be converted to a {@code Double}.\n     * @throws    NumberFormatException if the string does not contain a\n     *            parsable number.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseDouble(String)} to convert a string to a\n     * {@code double} primitive, or use {@link #valueOf(String)}\n     * to convert a string to a {@code Double} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Double(String s) throws NumberFormatException {\n        value \u003d parseDouble(s);\n    }\n\n    /**\n     * Returns {@code true} if this {@code Double} value is\n     * a Not-a-Number (NaN), {@code false} otherwise.\n     *\n     * @return  {@code true} if the value represented by this object is\n     *          NaN; {@code false} otherwise.\n     */\n    public boolean isNaN() {\n        return isNaN(value);\n    }\n\n    /**\n     * Returns {@code true} if this {@code Double} value is\n     * infinitely large in magnitude, {@code false} otherwise.\n     *\n     * @return  {@code true} if the value represented by this object is\n     *          positive infinity or negative infinity;\n     *          {@code false} otherwise.\n     */\n    public boolean isInfinite() {\n        return isInfinite(value);\n    }\n\n    /**\n     * Returns a string representation of this {@code Double} object.\n     * The primitive {@code double} value represented by this\n     * object is converted to a string exactly as if by the method\n     * {@code toString} of one argument.\n     *\n     * @return  a {@code String} representation of this object.\n     * @see java.lang.Double#toString(double)\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns the value of this {@code Double} as a {@code byte}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code byte}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     * @since 1.1\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Double} as a {@code short}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code short}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     * @since 1.1\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Double} as an {@code int}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code int}\n     */\n    public int intValue() {\n        return (int)value;\n    }\n\n    /**\n     * Returns the value of this {@code Double} as a {@code long}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code long}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Double} as a {@code float}\n     * after a narrowing primitive conversion.\n     *\n     * @return  the {@code double} value represented by this object\n     *          converted to type {@code float}\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     * @since 1.0\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the {@code double} value of this {@code Double} object.\n     *\n     * @return the {@code double} value represented by this object\n     */\n    @IntrinsicCandidate\n    public double doubleValue() {\n        return value;\n    }\n\n    /**\n     * Returns a hash code for this {@code Double} object. The\n     * result is the exclusive OR of the two halves of the\n     * {@code long} integer bit representation, exactly as\n     * produced by the method {@link #doubleToLongBits(double)}, of\n     * the primitive {@code double} value represented by this\n     * {@code Double} object. That is, the hash code is the value\n     * of the expression:\n     *\n     * \u003cblockquote\u003e\n     *  {@code (int)(v^(v\u003e\u003e\u003e32))}\n     * \u003c/blockquote\u003e\n     *\n     * where {@code v} is defined by:\n     *\n     * \u003cblockquote\u003e\n     *  {@code long v \u003d Double.doubleToLongBits(this.doubleValue());}\n     * \u003c/blockquote\u003e\n     *\n     * @return  a {@code hash code} value for this object.\n     */\n    @Override\n    public int hashCode() {\n        return Double.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for a {@code double} value; compatible with\n     * {@code Double.hashCode()}.\n     *\n     * @param value the value to hash\n     * @return a hash code value for a {@code double} value.\n     * @since 1.8\n     */\n    public static int hashCode(double value) {\n        long bits \u003d doubleToLongBits(value);\n        return (int)(bits ^ (bits \u003e\u003e\u003e 32));\n    }\n\n    /**\n     * Compares this object against the specified object.  The result\n     * is {@code true} if and only if the argument is not\n     * {@code null} and is a {@code Double} object that\n     * represents a {@code double} that has the same value as the\n     * {@code double} represented by this object. For this\n     * purpose, two {@code double} values are considered to be\n     * the same if and only if the method {@link\n     * #doubleToLongBits(double)} returns the identical\n     * {@code long} value when applied to each.\n     *\n     * @apiNote\n     * This method is defined in terms of {@link\n     * #doubleToLongBits(double)} rather than the {@code \u003d\u003d} operator\n     * on {@code double} values since the {@code \u003d\u003d} operator does\n     * \u003cem\u003enot\u003c/em\u003e define an equivalence relation and to satisfy the\n     * {@linkplain Object#equals equals contract} an equivalence\n     * relation must be implemented; see \u003ca\n     * href\u003d\"#equivalenceRelation\"\u003ethis discussion\u003c/a\u003e for details of\n     * floating-point equality and equivalence.\n     *\n     * @see java.lang.Double#doubleToLongBits(double)\n     * @jls 15.21.1 Numerical Equality Operators \u003d\u003d and !\u003d\n     */\n    public boolean equals(Object obj) {\n        return (obj instanceof Double)\n               \u0026\u0026 (doubleToLongBits(((Double)obj).value) \u003d\u003d\n                      doubleToLongBits(value));\n    }\n\n    /**\n     * Returns a representation of the specified floating-point value\n     * according to the IEEE 754 floating-point \"double\n     * format\" bit layout.\n     *\n     * \u003cp\u003eBit 63 (the bit that is selected by the mask\n     * {@code 0x8000000000000000L}) represents the sign of the\n     * floating-point number. Bits\n     * 62-52 (the bits that are selected by the mask\n     * {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0\n     * (the bits that are selected by the mask\n     * {@code 0x000fffffffffffffL}) represent the significand\n     * (sometimes called the mantissa) of the floating-point number.\n     *\n     * \u003cp\u003eIf the argument is positive infinity, the result is\n     * {@code 0x7ff0000000000000L}.\n     *\n     * \u003cp\u003eIf the argument is negative infinity, the result is\n     * {@code 0xfff0000000000000L}.\n     *\n     * \u003cp\u003eIf the argument is NaN, the result is\n     * {@code 0x7ff8000000000000L}.\n     *\n     * \u003cp\u003eIn all cases, the result is a {@code long} integer that, when\n     * given to the {@link #longBitsToDouble(long)} method, will produce a\n     * floating-point value the same as the argument to\n     * {@code doubleToLongBits} (except all NaN values are\n     * collapsed to a single \"canonical\" NaN value).\n     *\n     * @param   value   a {@code double} precision floating-point number.\n     * @return the bits that represent the floating-point number.\n     */\n    @IntrinsicCandidate\n    public static long doubleToLongBits(double value) {\n        if (!isNaN(value)) {\n            return doubleToRawLongBits(value);\n        }\n        return 0x7ff8000000000000L;\n    }\n\n    /**\n     * Returns a representation of the specified floating-point value\n     * according to the IEEE 754 floating-point \"double\n     * format\" bit layout, preserving Not-a-Number (NaN) values.\n     *\n     * \u003cp\u003eBit 63 (the bit that is selected by the mask\n     * {@code 0x8000000000000000L}) represents the sign of the\n     * floating-point number. Bits\n     * 62-52 (the bits that are selected by the mask\n     * {@code 0x7ff0000000000000L}) represent the exponent. Bits 51-0\n     * (the bits that are selected by the mask\n     * {@code 0x000fffffffffffffL}) represent the significand\n     * (sometimes called the mantissa) of the floating-point number.\n     *\n     * \u003cp\u003eIf the argument is positive infinity, the result is\n     * {@code 0x7ff0000000000000L}.\n     *\n     * \u003cp\u003eIf the argument is negative infinity, the result is\n     * {@code 0xfff0000000000000L}.\n     *\n     * \u003cp\u003eIf the argument is NaN, the result is the {@code long}\n     * integer representing the actual NaN value.  Unlike the\n     * {@code doubleToLongBits} method,\n     * {@code doubleToRawLongBits} does not collapse all the bit\n     * patterns encoding a NaN to a single \"canonical\" NaN\n     * value.\n     *\n     * \u003cp\u003eIn all cases, the result is a {@code long} integer that,\n     * when given to the {@link #longBitsToDouble(long)} method, will\n     * produce a floating-point value the same as the argument to\n     * {@code doubleToRawLongBits}.\n     *\n     * @param   value   a {@code double} precision floating-point number.\n     * @return the bits that represent the floating-point number.\n     * @since 1.3\n     */\n    @IntrinsicCandidate\n    public static native long doubleToRawLongBits(double value);\n\n    /**\n     * Returns the {@code double} value corresponding to a given\n     * bit representation.\n     * The argument is considered to be a representation of a\n     * floating-point value according to the IEEE 754 floating-point\n     * \"double format\" bit layout.\n     *\n     * \u003cp\u003eIf the argument is {@code 0x7ff0000000000000L}, the result\n     * is positive infinity.\n     *\n     * \u003cp\u003eIf the argument is {@code 0xfff0000000000000L}, the result\n     * is negative infinity.\n     *\n     * \u003cp\u003eIf the argument is any value in the range\n     * {@code 0x7ff0000000000001L} through\n     * {@code 0x7fffffffffffffffL} or in the range\n     * {@code 0xfff0000000000001L} through\n     * {@code 0xffffffffffffffffL}, the result is a NaN.  No IEEE\n     * 754 floating-point operation provided by Java can distinguish\n     * between two NaN values of the same type with different bit\n     * patterns.  Distinct values of NaN are only distinguishable by\n     * use of the {@code Double.doubleToRawLongBits} method.\n     *\n     * \u003cp\u003eIn all other cases, let \u003ci\u003es\u003c/i\u003e, \u003ci\u003ee\u003c/i\u003e, and \u003ci\u003em\u003c/i\u003e be three\n     * values that can be computed from the argument:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e{@code\n     * int s \u003d ((bits \u003e\u003e 63) \u003d\u003d 0) ? 1 : -1;\n     * int e \u003d (int)((bits \u003e\u003e 52) \u0026 0x7ffL);\n     * long m \u003d (e \u003d\u003d 0) ?\n     *                 (bits \u0026 0xfffffffffffffL) \u003c\u003c 1 :\n     *                 (bits \u0026 0xfffffffffffffL) | 0x10000000000000L;\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Then the floating-point result equals the value of the mathematical\n     * expression \u003ci\u003es\u003c/i\u003e\u0026middot;\u003ci\u003em\u003c/i\u003e\u0026middot;2\u003csup\u003e\u003ci\u003ee\u003c/i\u003e-1075\u003c/sup\u003e.\n     *\n     * \u003cp\u003eNote that this method may not be able to return a\n     * {@code double} NaN with exactly same bit pattern as the\n     * {@code long} argument.  IEEE 754 distinguishes between two\n     * kinds of NaNs, quiet NaNs and \u003ci\u003esignaling NaNs\u003c/i\u003e.  The\n     * differences between the two kinds of NaN are generally not\n     * visible in Java.  Arithmetic operations on signaling NaNs turn\n     * them into quiet NaNs with a different, but often similar, bit\n     * pattern.  However, on some processors merely copying a\n     * signaling NaN also performs that conversion.  In particular,\n     * copying a signaling NaN to return it to the calling method\n     * may perform this conversion.  So {@code longBitsToDouble}\n     * may not be able to return a {@code double} with a\n     * signaling NaN bit pattern.  Consequently, for some\n     * {@code long} values,\n     * {@code doubleToRawLongBits(longBitsToDouble(start))} may\n     * \u003ci\u003enot\u003c/i\u003e equal {@code start}.  Moreover, which\n     * particular bit patterns represent signaling NaNs is platform\n     * dependent; although all NaN bit patterns, quiet or signaling,\n     * must be in the NaN range identified above.\n     *\n     * @param   bits   any {@code long} integer.\n     * @return  the {@code double} floating-point value with the same\n     *          bit pattern.\n     */\n    @IntrinsicCandidate\n    public static native double longBitsToDouble(long bits);\n\n    /**\n     * Compares two {@code Double} objects numerically.\n     *\n     * This method imposes a total order on {@code Double} objects\n     * with two differences compared to the incomplete order defined by\n     * the Java language numerical comparison operators ({@code \u003c, \u003c\u003d,\n     * \u003d\u003d, \u003e\u003d, \u003e}) on {@code double} values.\n     *\n     * \u003cul\u003e\u003cli\u003e A NaN is \u003cem\u003eunordered\u003c/em\u003e with respect to other\n     *          values and unequal to itself under the comparison\n     *          operators.  This method chooses to define {@code\n     *          Double.NaN} to be equal to itself and greater than all\n     *          other {@code double} values (including {@code\n     *          Double.POSITIVE_INFINITY}).\n     *\n     *      \u003cli\u003e Positive zero and negative zero compare equal\n     *      numerically, but are distinct and distinguishable values.\n     *      This method chooses to define positive zero ({@code +0.0d}),\n     *      to be greater than negative zero ({@code -0.0d}).\n     * \u003c/ul\u003e\n\n     * This ensures that the \u003ci\u003enatural ordering\u003c/i\u003e of {@code Double}\n     * objects imposed by this method is \u003ci\u003econsistent with\n     * equals\u003c/i\u003e; see \u003ca href\u003d\"#equivalenceRelation\"\u003ethis\n     * discussion\u003c/a\u003e for details of floating-point comparison and\n     * ordering.\n     *\n     * @param   anotherDouble   the {@code Double} to be compared.\n     * @return  the value {@code 0} if {@code anotherDouble} is\n     *          numerically equal to this {@code Double}; a value\n     *          less than {@code 0} if this {@code Double}\n     *          is numerically less than {@code anotherDouble};\n     *          and a value greater than {@code 0} if this\n     *          {@code Double} is numerically greater than\n     *          {@code anotherDouble}.\n     *\n     * @jls 15.20.1 Numerical Comparison Operators {@code \u003c}, {@code \u003c\u003d}, {@code \u003e}, and {@code \u003e\u003d}\n     * @since   1.2\n     */\n    public int compareTo(Double anotherDouble) {\n        return Double.compare(value, anotherDouble.value);\n    }\n\n    /**\n     * Compares the two specified {@code double} values. The sign\n     * of the integer value returned is the same as that of the\n     * integer that would be returned by the call:\n     * \u003cpre\u003e\n     *    new Double(d1).compareTo(new Double(d2))\n     * \u003c/pre\u003e\n     *\n     * @param   d1        the first {@code double} to compare\n     * @param   d2        the second {@code double} to compare\n     * @return  the value {@code 0} if {@code d1} is\n     *          numerically equal to {@code d2}; a value less than\n     *          {@code 0} if {@code d1} is numerically less than\n     *          {@code d2}; and a value greater than {@code 0}\n     *          if {@code d1} is numerically greater than\n     *          {@code d2}.\n     * @since 1.4\n     */\n    public static int compare(double d1, double d2) {\n        if (d1 \u003c d2)\n            return -1;           // Neither val is NaN, thisVal is smaller\n        if (d1 \u003e d2)\n            return 1;            // Neither val is NaN, thisVal is larger\n\n        // Cannot use doubleToRawLongBits because of possibility of NaNs.\n        long thisBits    \u003d Double.doubleToLongBits(d1);\n        long anotherBits \u003d Double.doubleToLongBits(d2);\n\n        return (thisBits \u003d\u003d anotherBits ?  0 : // Values are equal\n                (thisBits \u003c anotherBits ? -1 : // (-0.0, 0.0) or (!NaN, NaN)\n                 1));                          // (0.0, -0.0) or (NaN, !NaN)\n    }\n\n    /**\n     * Adds two {@code double} values together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @jls 4.2.4 Floating-Point Operations\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static double sum(double a, double b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code double} values\n     * as if by calling {@link Math#max(double, double) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static double max(double a, double b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code double} values\n     * as if by calling {@link Math#min(double, double) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}.\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static double min(double a, double b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Double} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cDouble\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Double} instance\n     * @since 12\n     */\n    @Override\n    public Double resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -9172774392245257468L;\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Double.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Double.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Jan 09, 2024 9:52:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17.0.8.1%2B1/lib/src.zip%21/java.base/java/lang/Double.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Double.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:684)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:681)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17.0.8.1 1/lib/src.zip!/java.base/java/lang/Double.java
	at java.base/java.net.URI$Parser.fail(URI.java:2976)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3147)
	at java.base/java.net.URI$Parser.parse(URI.java:3183)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

Exception in thread "pool-3-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Exception in thread "pool-3-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:230)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.01.09 09:52:51 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 09:52:51 INFO  skipping build import with status 'Dismissed'
2024.01.09 09:53:08 WARN  Could not find semantic tokens for: file:///C:/Users/Arnav/Documents/GitHub/apl/apl/line.scala
2024.01.09 09:53:08 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
2024.01.09 09:53:08 INFO  skipping build import with status 'Dismissed'
2024.01.09 09:53:08 WARN  Could not find semantic tokens for: file:///C:/Users/Arnav/Documents/GitHub/apl/apl/line.scala
2024.01.09 09:53:09 WARN  Could not find semantic tokens for: file:///C:/Users/Arnav/Documents/GitHub/apl/apl/index.scala
2024.01.09 09:53:26 WARN  Could not find semantic tokens for: file:///C:/Users/Arnav/Documents/GitHub/apl/apl/line.scala
2024.01.09 09:53:28 WARN  Could not find semantic tokens for: file:///C:/Users/Arnav/Documents/GitHub/apl/apl/index.scala
2024.01.09 09:53:40 WARN  Could not find semantic tokens for: file:///C:/Users/Arnav/Documents/GitHub/apl/apl/line.scala
2024.01.09 09:53:41 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\line.scala
2024.01.09 09:53:41 INFO  skipping build import with status 'Dismissed'
2024.01.09 09:53:41 WARN  Could not find semantic tokens for: file:///C:/Users/Arnav/Documents/GitHub/apl/apl/line.scala
2024.01.09 09:53:43 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 09:53:43 INFO  skipping build import with status 'Dismissed'
2024.01.09 09:53:43 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\index.scala
2024.01.09 09:53:43 INFO  skipping build import with status 'Dismissed'
Jan 09, 2024 9:53:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3333
2024.01.09 09:53:43 WARN  Could not find semantic tokens for: file:///C:/Users/Arnav/Documents/GitHub/apl/apl/index.scala
2024.01.09 09:54:35 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 09:54:35 INFO  skipping build import with status 'Dismissed'
2024.01.09 09:54:50 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 09:54:50 INFO  skipping build import with status 'Dismissed'
2024.01.09 09:57:51 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 10:00:51 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 10:00:51 INFO  skipping build import with status 'Dismissed'
2024.01.09 10:01:46 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 10:01:46 INFO  skipping build import with status 'Dismissed'
2024.01.09 10:02:27 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 10:02:27 INFO  skipping build import with status 'Dismissed'
2024.01.09 10:03:22 WARN  no build target for: C:\Users\Arnav\Documents\GitHub\apl\apl\util.scala
2024.01.09 10:03:22 INFO  skipping build import with status 'Dismissed'
